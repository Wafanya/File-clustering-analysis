<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <title>Multi-Product Document Analyzer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 10px;
            color: #333;
            zoom: 0.8;
            transform-origin: top left;
        }

        /* Login Screen Styles */
        #loginScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }

        #loginScreen.hidden {
            display: none;
        }

        .login-container {
            background: white;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            width: 90%;
            text-align: center;
        }

        .login-container h2 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 1.8em;
        }

        .login-container p {
            color: #6b7280;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .login-input {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 16px;
            margin-bottom: 20px;
            transition: all 0.2s;
        }

        .login-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .login-button {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.1s;
        }

        .login-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .login-button:active {
            transform: translateY(0);
        }

        .login-error {
            color: #ef4444;
            font-size: 14px;
            margin-top: 10px;
            min-height: 20px;
        }

        #mainApp {
            display: none;
        }

        #mainApp.authenticated {
            display: block;
        }
        
        @media (min-width: 1400px) {
            body {
                zoom: 1;
            }
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 20px;
        }

        .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            gap: 15px;
        }

        .header h1 {
            font-size: 1.5em;
            margin: 0;
            font-weight: 600;
        }

        .header-search {
            display: flex;
            align-items: center;
            flex: 1;
            max-width: 400px;
            position: relative;
        }
        
        .global-search-wrapper {
            position: relative;
            flex: 1;
        }
        
        .global-search-input {
            padding: 10px 40px 10px 16px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.95);
            color: #212529;
            width: 100%;
            transition: all 0.2s;
        }
        
        .global-search-input:focus {
            outline: none;
            border-color: white;
            background: white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .global-search-input::placeholder {
            color: #6c757d;
        }
        
        .global-search-icon {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: #6c757d;
            pointer-events: none;
            font-size: 16px;
        }
        
        .email-autocomplete {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            margin-top: 4px;
            max-height: 300px;
            overflow-y: auto;
            z-index: 10000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            display: none;
        }
        
        .email-autocomplete-item {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid #e9ecef;
            transition: background 0.2s;
        }
        
        .email-autocomplete-item:hover {
            background: #f8f9fa;
        }
        
        .email-autocomplete-item:last-child {
            border-bottom: none;
        }
        
        .email-autocomplete-email {
            font-weight: 600;
            color: #212529;
            margin-bottom: 4px;
        }
        
        .email-autocomplete-product {
            font-size: 12px;
            color: #6c757d;
        }
        
        .email-autocomplete-product-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            background: #667eea;
            color: white;
            font-weight: 600;
            margin-right: 6px;
        }
        
        .product-selector {
            display: flex;
            gap: 6px;
            background: rgba(255, 255, 255, 0.2);
            padding: 6px;
            border-radius: 6px;
        }

        .product-btn {
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid transparent;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            font-weight: 600;
            font-size: 13px;
            transition: all 0.3s;
            white-space: nowrap;
        }

        .product-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .product-btn.active {
            background: white;
            color: #667eea;
            border-color: white;
        }

        .stats-bar {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.2);
            padding: 15px 25px;
            border-radius: 8px;
        }

        .main-content {
            display: grid;
            grid-template-columns: 260px 1fr;
            min-height: 500px;
        }

        .sidebar {
            background: #ffffff;
            border-right: 1px solid #e5e7eb;
            padding: 12px 0;
            overflow-y: auto;
            max-height: calc(100vh - 140px);
            width: 240px;
            min-width: 240px;
        }

        .sidebar-section {
            margin-bottom: 20px;
            padding: 0 12px;
        }

        .sidebar-section:first-child {
            margin-top: 0;
        }

        .sidebar-section h3 {
            color: #6b7280;
            margin-bottom: 8px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 0 16px;
            margin-top: 0;
        }

        .view-btn {
            display: flex;
            align-items: center;
            width: 100%;
            padding: 8px 14px;
            margin-bottom: 2px;
            background: transparent;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            text-align: left;
            font-size: 13px;
            font-weight: 400;
            transition: all 0.15s ease;
            color: #374151;
            position: relative;
            gap: 12px;
        }

        .view-btn:hover {
            background: #f3f4f6;
            color: #111827;
        }

        .view-btn.active {
            background: #eff6ff;
            color: #2563eb;
            font-weight: 500;
        }

        .view-btn.active::after {
            content: '';
            position: absolute;
            right: 12px;
            width: 6px;
            height: 6px;
            background: #2563eb;
            border-radius: 50%;
        }

        .view-btn-icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            font-size: 18px;
        }

        .view-btn.active .view-btn-icon {
            opacity: 1;
        }

        .content-area {
            padding: 16px 20px;
            overflow-y: auto;
            max-height: calc(100vh - 140px);
            background: #f9fafb;
            position: relative;
        }

        .view-panel {
            display: none;
        }

        .view-panel.active {
            display: block;
        }

        .level-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            align-items: center;
        }

        .level-btn {
            padding: 10px 20px;
            background: white;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }

        .level-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .chart-container {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
            position: relative;
            min-height: 600px;
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        .chart-wrapper {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 550px;
            position: relative;
        }
        
        .chart-stats-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .chart-stat-item {
            font-size: 14px;
            color: #333;
        }
        
        .chart-stat-item strong {
            color: #666;
            margin-right: 5px;
        }

        .chart-legend {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            max-width: 300px;
            max-height: 500px;
            overflow-y: auto;
            min-width: 250px;
        }

        .legend-title {
            font-weight: 600;
            font-size: 1.1em;
            margin-bottom: 15px;
            color: #495057;
            border-bottom: 2px solid #dee2e6;
            padding-bottom: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #f0f0f0;
            cursor: pointer;
            transition: background 0.2s;
        }

        .legend-item:hover {
            background: #f8f9fa;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            margin-right: 10px;
            flex-shrink: 0;
            border: 2px solid #fff;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .legend-text {
            flex: 1;
            font-size: 0.9em;
            color: #495057;
        }

        .legend-name {
            font-weight: 500;
            margin-bottom: 2px;
        }

        .legend-percentage {
            font-size: 0.85em;
            color: #6c757d;
            font-weight: 600;
        }

        #pieChartCanvas {
            cursor: pointer;
            max-width: 100%;
        }

        .category-list {
            display: grid;
            gap: 15px;
        }

        .category-card {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            padding: 25px;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        .category-card:hover {
            border-color: #667eea;
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.15);
            transform: translateY(-2px);
        }

        .analysis-summary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 16px 20px;
            border-radius: 8px;
            margin-bottom: 16px;
        }

        .analysis-summary h2 {
            margin: 0 0 12px 0;
            font-size: 1.4em;
        }

        .summary-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
        }

        .summary-metric {
            background: rgba(255, 255, 255, 0.15);
            padding: 12px;
            border-radius: 6px;
            backdrop-filter: blur(10px);
        }

        .summary-metric-label {
            font-size: 0.9em;
            opacity: 0.9;
            margin-bottom: 8px;
        }

        .summary-metric-value {
            font-size: 1.6em;
            font-weight: bold;
        }

        .analysis-filters {
            display: flex;
            gap: 12px;
            margin-bottom: 16px;
            flex-wrap: wrap;
            align-items: center;
        }

        .filter-input {
            padding: 10px 15px;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            font-size: 14px;
            min-width: 200px;
        }

        .filter-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .analysis-card {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 20px;
            transition: all 0.2s;
        }

        .analysis-card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #f0f0f0;
        }

        .analysis-card-title {
            font-size: 1.4em;
            font-weight: 600;
            color: #212529;
            margin: 0;
        }

        .analysis-card-stats {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .analysis-stat {
            text-align: center;
        }

        .analysis-stat-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #667eea;
            display: block;
        }

        .analysis-stat-label {
            font-size: 0.85em;
            color: #6c757d;
            margin-top: 5px;
        }

        .percentage-display {
            display: flex;
            align-items: center;
            gap: 15px;
            margin: 15px 0;
        }

        .percentage-value {
            font-size: 2.5em;
            font-weight: bold;
            color: #667eea;
            min-width: 120px;
            text-align: center;
        }

        .percentage-details {
            flex: 1;
        }

        .percentage-bar-large {
            width: 100%;
            height: 16px;
            background: #e9ecef;
            border-radius: 8px;
            overflow: hidden;
            margin-top: 10px;
        }

        .percentage-fill-large {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            border-radius: 8px;
            transition: width 0.5s ease;
        }

        /* Loader styles - integrated into interface */
        .loader-indicator {
            display: none;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 6px;
            font-size: 14px;
            color: #667eea;
            transition: opacity 0.3s ease;
        }

        .loader-indicator.active {
            display: flex;
        }

        .loader-spinner-small {
            width: 16px;
            height: 16px;
            border: 2px solid rgba(102, 126, 234, 0.2);
            border-top: 2px solid #667eea;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loader-text-small {
            font-size: 14px;
            font-weight: 500;
            color: #667eea;
        }

        /* Chart loader - integrated into chart container */
        .chart-loader {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(248, 249, 250, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 20px;
            z-index: 100;
            border-radius: 8px;
        }

        .chart-loader.active {
            display: flex;
        }

        .chart-loader-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #e9ecef;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        .chart-loader-text {
            font-size: 16px;
            font-weight: 600;
            color: #667eea;
            text-align: center;
        }

        .chart-loader-subtext {
            font-size: 14px;
            color: #6c757d;
            text-align: center;
        }

        /* Notification styles */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #fff;
            border: 2px solid #dc3545;
            border-radius: 8px;
            padding: 16px 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 10000;
            max-width: 400px;
            display: none;
            animation: slideInRight 0.3s ease-out;
        }

        .notification.show {
            display: block;
        }

        .notification.error {
            border-color: #dc3545;
            background: #fff5f5;
        }

        .notification.error .notification-icon {
            color: #dc3545;
        }

        .notification-content {
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }

        .notification-icon {
            font-size: 20px;
            flex-shrink: 0;
            margin-top: 2px;
        }

        .notification-message {
            flex: 1;
            color: #212529;
            font-size: 14px;
            line-height: 1.5;
        }

        .notification-close {
            background: none;
            border: none;
            font-size: 20px;
            color: #6c757d;
            cursor: pointer;
            padding: 0;
            margin-left: 12px;
            flex-shrink: 0;
            line-height: 1;
            transition: color 0.2s;
        }

        .notification-close:hover {
            color: #212529;
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .category-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .category-name {
            font-size: 1.3em;
            font-weight: 600;
            color: #212529;
        }

        .category-count {
            font-size: 1.1em;
            color: #667eea;
            font-weight: 600;
        }

        .metric-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .metric-label {
            color: #6c757d;
            font-size: 0.9em;
        }

        .metric-value {
            font-weight: 600;
            color: #212529;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 5px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s;
        }

        .tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 14px 18px;
            border-radius: 10px;
            pointer-events: none;
            z-index: 10000;
            font-size: 13px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
            display: none;
            max-width: 400px;
            max-height: 80vh;
            overflow-y: auto;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .tooltip-title {
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 10px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.4);
            padding-bottom: 8px;
        }

        .tooltip-line {
            margin: 6px 0;
            line-height: 1.5;
        }

        .tooltip-section {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid rgba(255, 255, 255, 0.3);
        }

        .tooltip-section-title {
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 8px;
            color: #a8d8ff;
        }

        #imageTypesContent {
            width: 100%;
        }

        .enhanced-dropdown {
            width: 100%;
            padding: 20px 24px;
            border: 3px solid #dee2e6;
            border-radius: 12px;
            font-size: 18px;
            font-weight: 600;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='20' height='20' viewBox='0 0 20 20'%3E%3Cpath fill='%23667eea' d='M10 14L4 8h12z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 24px center;
            padding-right: 60px;
            min-height: 68px;
            line-height: 1.6;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .enhanced-dropdown:hover {
            border-color: #667eea;
            background-color: #f8f9ff;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
            transform: translateY(-1px);
        }

        .enhanced-dropdown:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 5px rgba(102, 126, 234, 0.2), 0 4px 12px rgba(102, 126, 234, 0.2);
        }

        .enhanced-dropdown option {
            padding: 16px 20px;
            font-size: 16px;
            line-height: 2;
            font-weight: normal;
        }

        .enhanced-dropdown option[value=""] {
            color: #6c757d;
            font-style: italic;
            font-weight: 500;
        }

        .category-option-core {
            font-weight: 600;
            color: #667eea;
        }
        
        /* User Records Browser Styles */
        .user-records-container {
            background: white;
            border-radius: 8px;
            padding: 16px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
            position: relative;
            display: flex;
            flex-direction: column;
            min-height: calc(100vh - 200px);
        }
        
        .user-search-section {
            margin-bottom: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            background: #f8f9fa;
            padding: 16px;
            border-radius: 8px;
            border: 2px solid #e9ecef;
        }
        
        .search-box {
            display: flex;
            gap: 12px;
        }
        
        .user-search-input {
            flex: 1;
            padding: 16px 20px;
            border: 3px solid #dee2e6;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 500;
            transition: all 0.2s;
        }
        
        .user-search-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .search-btn {
            padding: 16px 32px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 600;
            font-size: 16px;
            transition: all 0.2s;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }
        
        .search-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }
        
        .search-btn:active {
            transform: translateY(0);
        }
        
        .user-navigation {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 25px;
            padding: 20px;
            margin-top: auto;
            background: #f8f9fa;
            border-radius: 12px;
            border-top: 2px solid #e9ecef;
            position: sticky;
            bottom: 0;
            z-index: 10;
            border-top: 2px solid #e9ecef;
        }
        
        .nav-btn {
            padding: 14px 28px;
            background: white;
            border: 3px solid #dee2e6;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 600;
            font-size: 15px;
            color: #495057;
            transition: all 0.2s;
            min-width: 120px;
        }
        
        .nav-btn:hover:not(:disabled) {
            background: #667eea;
            border-color: #667eea;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }
        
        .nav-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            background: #f8f9fa;
        }
        
        .user-counter {
            font-weight: 700;
            font-size: 18px;
            color: #667eea;
            min-width: 120px;
            text-align: center;
            padding: 12px 20px;
            background: white;
            border-radius: 12px;
            border: 2px solid #e9ecef;
        }
        
        .user-details {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 30px;
            min-height: 400px;
        }
        
        .empty-user-state {
            text-align: center;
            color: #6c757d;
            padding: 60px 40px;
            font-style: italic;
            font-size: 16px;
        }
        
        .user-details {
            padding: 0;
            overflow: visible;
            flex: 1;
            margin-bottom: 20px;
        }
        
        .user-detail-card {
            background: white;
            border-radius: 12px;
            padding: 18px 20px;
            margin-bottom: 0;
            border-left: 5px solid #667eea;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            transition: all 0.2s;
        }
        
        .user-detail-card:hover {
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.15);
            transform: translateY(-2px);
        }
        
        .user-detail-card h3 {
            margin-top: 0;
            margin-bottom: 16px;
            color: #2563eb;
            font-size: 1.5em;
            font-weight: 700;
            padding-bottom: 12px;
            border-bottom: 2px solid #e5e7eb;
        }
        
        .user-detail-card > p {
            margin-bottom: 16px !important;
            font-size: 0.95em !important;
            color: #6b7280;
        }
        
        .user-detail-rows-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px 20px;
        }
        
        .user-detail-row {
            display: flex;
            flex-direction: column;
            padding: 6px 0;
            border-bottom: 1px solid #e9ecef;
            gap: 4px;
        }
        
        .user-detail-row:last-child {
            border-bottom: none;
        }
        
        .user-detail-label {
            font-weight: 600;
            color: #6b7280;
            font-size: 13px;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .user-detail-value {
            color: #111827;
            font-size: 15px;
            line-height: 1.5;
            word-break: break-word;
            font-weight: 400;
        }
        
        .user-detail-badge {
            display: inline-block;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
            margin-right: 8px;
            margin-bottom: 4px;
        }
        
        .badge-true {
            background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
            color: #155724;
            border: 1px solid #b8dacc;
        }
        
        .badge-false {
            background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);
            color: #721c24;
            border: 1px solid #f1b0b7;
        }

        .filters-bar {
            display: flex;
            gap: 12px;
            align-items: center;
            padding: 10px 16px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 8px;
            margin-top: 8px;
            flex-wrap: wrap;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        .filters-title {
            font-weight: 700;
            color: #495057;
            margin-right: 8px;
            font-size: 14px;
            white-space: nowrap;
        }

        .multi-select-wrapper {
            position: relative;
            min-width: 220px;
        }

        .multi-select {
            position: relative;
            width: 100%;
        }

        .multi-select-display {
            padding: 18px 24px;
            border: 3px solid #dee2e6;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
            min-height: 60px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .multi-select-display:hover {
            border-color: #667eea;
            background-color: #f8f9ff;
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.15);
        }

        .multi-select.active .multi-select-display {
            border-color: #667eea;
            box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.15), 0 4px 8px rgba(102, 126, 234, 0.15);
        }

        .multi-select-text {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            color: #212529;
            font-weight: 600;
        }

        .multi-select-arrow {
            margin-left: 10px;
            color: #667eea;
            font-size: 12px;
            transition: transform 0.2s;
        }

        .multi-select.active .multi-select-arrow {
            transform: rotate(180deg);
        }

        .multi-select-dropdown {
            display: none !important;
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 3px solid #667eea;
            border-radius: 12px;
            margin-top: 8px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            max-height: 400px;
            overflow: hidden;
        }

        .multi-select.active .multi-select-dropdown {
            display: block !important;
        }

        .multi-select-search {
            width: 100%;
            padding: 14px 18px;
            border: none;
            border-bottom: 2px solid #f0f0f0;
            font-size: 15px;
            outline: none;
            font-weight: 500;
        }

        .multi-select-search:focus {
            border-bottom-color: #667eea;
        }

        .multi-select-options {
            max-height: 300px;
            overflow-y: auto;
        }

        .multi-select-option {
            padding: 14px 18px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 12px;
            border-bottom: 1px solid #f0f0f0;
        }

        .multi-select-option:last-child {
            border-bottom: none;
        }

        .multi-select-option:hover {
            background: #f8f9ff;
        }

        .multi-select-option input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: #667eea;
            flex-shrink: 0;
        }

        .multi-select-option-label {
            flex: 1;
            font-size: 15px;
            user-select: none;
            font-weight: 500;
            color: #212529;
        }

        .multi-select-option.selected {
            background: #f0f4ff;
            font-weight: 600;
        }

        .multi-select-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 18px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
        }

        .multi-select-section-title {
            font-weight: 600;
            font-size: 13px;
            color: #495057;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .multi-select-actions {
            display: flex;
            gap: 12px;
        }

        .multi-select-action-link {
            color: #667eea;
            text-decoration: none;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: color 0.2s;
        }

        .multi-select-action-link:hover {
            color: #764ba2;
            text-decoration: underline;
        }

        .multi-select-selected {
            max-height: 150px;
            overflow-y: auto;
            border-bottom: 1px solid #e9ecef;
        }

        .multi-select-selected:empty {
            display: none;
        }

        .multi-select-divider {
            height: 1px;
            background: #e9ecef;
            margin: 0;
        }

        /* Date Filter Styles */
        .date-filter-wrapper {
            position: relative;
            min-width: 200px;
        }

        .date-filter-display {
            padding: 18px 24px;
            border: 3px solid #dee2e6;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
            min-height: 60px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            color: #212529;
        }

        .date-filter-display:hover {
            border-color: #667eea;
            background-color: #f8f9ff;
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.15);
        }

        .date-filter-arrow {
            color: #6c757d;
            font-size: 12px;
            margin-left: 10px;
        }

        .date-filter-dropdown {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 8px;
            background: white;
            border: 3px solid #dee2e6;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            min-width: 320px;
            width: 100%;
            padding: 20px;
            box-sizing: border-box;
            overflow: visible;
        }

        .date-filter-wrapper.active .date-filter-dropdown {
            display: block;
        }

        .date-filter-modes {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 12px;
        }

        .date-mode-btn {
            flex: 1;
            padding: 10px 16px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            background: white;
            cursor: pointer;
            font-weight: 500;
            font-size: 14px;
            color: #495057;
            transition: all 0.2s;
        }

        .date-mode-btn:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .date-mode-btn.active {
            background: #2563eb;
            color: white;
            border-color: #2563eb;
        }

        .date-filter-content {
            width: 100%;
            min-height: 100px;
        }

        .date-mode-content {
            display: none;
            width: 100%;
        }

        .date-mode-content.active {
            display: block;
            width: 100%;
        }

        .date-preset-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 100%;
        }

        .date-preset-btn {
            padding: 12px 20px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            background: white;
            cursor: pointer;
            font-weight: 500;
            font-size: 14px;
            color: #495057;
            text-align: left;
            transition: all 0.2s;
        }

        .date-preset-btn:hover {
            border-color: #2563eb;
            background: #eff6ff;
            color: #2563eb;
        }

        .date-input-group {
            margin-bottom: 15px;
        }

        .date-input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #495057;
            font-size: 14px;
        }

        .date-input {
            width: 100%;
            padding: 12px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 14px;
            color: #212529;
            background: white;
        }

        .date-input:focus {
            outline: none;
            border-color: #2563eb;
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .date-apply-btn {
            width: 100%;
            padding: 12px;
            background: #2563eb;
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 10px;
        }

        .date-apply-btn:hover {
            background: #1d4ed8;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
        }

        .date-filter-actions {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 2px solid #e9ecef;
        }

        .date-cancel-btn {
            width: 100%;
            padding: 12px;
            background: #f3f4f6;
            color: #495057;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .date-cancel-btn:hover {
            background: #e9ecef;
            border-color: #adb5bd;
        }

        .filter-clear-btn {
            padding: 18px 24px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-left: auto;
            min-height: 60px;
        }

        .filter-clear-btn:hover {
            background: #5a6268;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .image-types-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .image-type-card {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            padding: 20px;
            transition: all 0.2s;
        }

        .image-type-card:hover {
            border-color: #667eea;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
            transform: translateY(-2px);
        }

        .image-type-name {
            font-weight: 600;
            margin-bottom: 8px;
            color: #495057;
            font-size: 1.1em;
        }

        .loading {
            text-align: center;
            padding: 60px 20px;
            color: #667eea;
            font-size: 1.2em;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #6c757d;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            max-width: 900px;
            max-height: 90vh;
            width: 100%;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        .modal-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px 30px;
            border-radius: 12px 12px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h2 {
            margin: 0;
            font-size: 1.8em;
        }

        .modal-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            font-size: 24px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .modal-close:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .modal-body {
            padding: 30px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .stat-card-label {
            font-size: 0.9em;
            color: #6c757d;
            margin-bottom: 8px;
        }

        .stat-card-value {
            font-size: 2em;
            font-weight: bold;
            color: #212529;
        }

        .detailed-section {
            margin-bottom: 30px;
        }

        .detailed-section h3 {
            color: #495057;
            margin-bottom: 15px;
            border-bottom: 2px solid #dee2e6;
            padding-bottom: 10px;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
        }

        .data-table th {
            background: #f8f9fa;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            color: #495057;
            border-bottom: 2px solid #dee2e6;
        }

        .data-table td {
            padding: 12px;
            border-bottom: 1px solid #e9ecef;
            font-size: 14px;
        }
        
        .data-table th {
            font-size: 14px;
        }
        
        #scanPhotoTable td,
        #scanPhotoTable th {
            font-size: 15px;
        }

        .data-table tr:hover {
            background: #f8f9fa;
        }

        .data-table th {
            cursor: pointer;
            user-select: none;
            position: relative;
        }

        .data-table th:hover {
            background: #e9ecef;
            cursor: pointer;
        }
        
        .data-table th:hover::after {
            content: " ‚áÖ";
            font-size: 0.85em;
            color: #667eea;
            font-weight: bold;
            margin-left: 4px;
            opacity: 0.7;
        }
        
        .data-table th.sort-asc:hover::after,
        .data-table th.sort-desc:hover::after {
            opacity: 1;
        }

        .data-table th.sort-asc::after {
            content: " ‚ñ≤";
            font-size: 0.85em;
            color: #2563eb;
            font-weight: bold;
            margin-left: 4px;
        }

        .data-table th.sort-desc::after {
            content: " ‚ñº";
            font-size: 0.85em;
            color: #2563eb;
            font-weight: bold;
            margin-left: 4px;
        }

        .comparison-bar {
            width: 120px;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .comparison-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            border-radius: 10px;
            transition: width 0.3s;
        }

        .comparison-value {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.75em;
            font-weight: 600;
            color: #495057;
            z-index: 1;
        }

        .comparison-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 250px 1fr;
            }
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            .sidebar {
                max-height: 300px;
            }
        }
    </style>
</head>
<body>
    <!-- Login Screen -->
    <div id="loginScreen">
        <div class="login-container">
            <h2>üîí Secure Access</h2>
            <p>Please enter the password to access the analyzer</p>
            <input type="password" id="passwordInput" class="login-input" placeholder="Enter password" autocomplete="off">
            <button id="loginButton" class="login-button">Login</button>
            <div id="loginError" class="login-error"></div>
        </div>
    </div>

    <!-- Main Application (hidden until authenticated) -->
    <div id="mainApp">
    <!-- Notification container -->
    <div id="notification" class="notification">
        <div class="notification-content">
            <span class="notification-icon">‚ö†Ô∏è</span>
            <span class="notification-message" id="notificationMessage"></span>
            <button class="notification-close" id="notificationClose" onclick="hideNotification()">√ó</button>
        </div>
    </div>
    
    <div class="container">
        <div class="header">
            <div class="header-top">
                <div style="flex-shrink: 0;">
                    <h1>üìä Multi-Product Document Analyzer</h1>
                </div>
                <div style="display: flex; align-items: center; gap: 12px; flex: 1; justify-content: flex-end;">
                    <div class="header-search">
                        <div class="global-search-wrapper">
                            <input type="text" id="globalSearch" class="global-search-input" placeholder="Search by User ID or Email..." onkeypress="if(event.key==='Enter') performGlobalSearch()" oninput="handleEmailAutocomplete(event)" onfocus="handleEmailAutocomplete(event)" onblur="setTimeout(() => hideEmailAutocomplete(), 200)">
                            <span class="global-search-icon">üîç</span>
                            <div id="emailAutocomplete" class="email-autocomplete"></div>
                        </div>
                    </div>
                    <div class="product-selector" id="productSelector">
                        <button class="product-btn" data-product="pdfguru">PDFGuru</button>
                        <button class="product-btn" data-product="pdfleader">PDFLeader</button>
                        <button class="product-btn" data-product="thebestpdf">TheBestPDF</button>
                        <div class="loader-indicator" id="headerLoader">
                            <div class="loader-spinner-small"></div>
                            <span class="loader-text-small" id="loaderText">Loading...</span>
                        </div>
                    </div>
                </div>
            </div>
            <div class="filters-bar" id="filtersBar" style="display: flex;">
                <div class="filters-title">üîç Filters:</div>
                <div class="multi-select-wrapper">
                    <div class="multi-select" id="filterCountryWrapper">
                        <div class="multi-select-display" onclick="toggleMultiSelect('filterCountry')">
                            <span class="multi-select-text">All Countries</span>
                            <span class="multi-select-arrow">‚ñº</span>
                        </div>
                        <div class="multi-select-dropdown" id="filterCountryDropdown">
                            <input type="text" class="multi-select-search" placeholder="üîç Search countries..." oninput="filterMultiSelect('filterCountry', this.value)">
                            <div class="multi-select-header" id="filterCountrySelectedHeader" style="display: none;">
                                <div class="multi-select-section-title">Selected Values</div>
                                <div class="multi-select-actions">
                                    <a href="#" class="multi-select-action-link" onclick="event.preventDefault(); clearAllOptions('filterCountry'); return false;">Clear all</a>
                                </div>
                            </div>
                            <div class="multi-select-selected" id="filterCountrySelected" style="display: none;"></div>
                            <div class="multi-select-divider" id="filterCountryDivider" style="display: none;"></div>
                            <div class="multi-select-header">
                                <div class="multi-select-section-title">All Values</div>
                                <div class="multi-select-actions">
                                    <a href="#" class="multi-select-action-link" onclick="event.preventDefault(); selectAllOptions('filterCountry'); return false;">Select all</a>
                                </div>
                            </div>
                            <div class="multi-select-options" id="filterCountryOptions"></div>
                        </div>
                    </div>
                </div>
                <div class="multi-select-wrapper">
                    <div class="multi-select" id="filterDeviceWrapper">
                        <div class="multi-select-display" onclick="toggleMultiSelect('filterDevice')">
                            <span class="multi-select-text">All Devices</span>
                            <span class="multi-select-arrow">‚ñº</span>
                        </div>
                        <div class="multi-select-dropdown" id="filterDeviceDropdown">
                            <div class="multi-select-header" id="filterDeviceSelectedHeader" style="display: none;">
                                <div class="multi-select-section-title">Selected Values</div>
                                <div class="multi-select-actions">
                                    <a href="#" class="multi-select-action-link" onclick="event.preventDefault(); clearAllOptions('filterDevice'); return false;">Clear all</a>
                                </div>
                            </div>
                            <div class="multi-select-selected" id="filterDeviceSelected" style="display: none;"></div>
                            <div class="multi-select-divider" id="filterDeviceDivider" style="display: none;"></div>
                            <div class="multi-select-header">
                                <div class="multi-select-section-title">All Values</div>
                                <div class="multi-select-actions">
                                    <a href="#" class="multi-select-action-link" onclick="event.preventDefault(); selectAllOptions('filterDevice'); return false;">Select all</a>
                                </div>
                            </div>
                            <div class="multi-select-options" id="filterDeviceOptions"></div>
                        </div>
                    </div>
                </div>
                <div class="multi-select-wrapper">
                    <div class="multi-select" id="filterFeatureWrapper">
                        <div class="multi-select-display" onclick="toggleMultiSelect('filterFeature')">
                            <span class="multi-select-text">All Features</span>
                            <span class="multi-select-arrow">‚ñº</span>
                        </div>
                        <div class="multi-select-dropdown" id="filterFeatureDropdown">
                            <input type="text" class="multi-select-search" placeholder="üîç Search features..." oninput="filterMultiSelect('filterFeature', this.value)">
                            <div class="multi-select-header" id="filterFeatureSelectedHeader" style="display: none;">
                                <div class="multi-select-section-title">Selected Values</div>
                                <div class="multi-select-actions">
                                    <a href="#" class="multi-select-action-link" onclick="event.preventDefault(); clearAllOptions('filterFeature'); return false;">Clear all</a>
                                </div>
                            </div>
                            <div class="multi-select-selected" id="filterFeatureSelected" style="display: none;"></div>
                            <div class="multi-select-divider" id="filterFeatureDivider" style="display: none;"></div>
                            <div class="multi-select-header">
                                <div class="multi-select-section-title">All Values</div>
                                <div class="multi-select-actions">
                                    <a href="#" class="multi-select-action-link" onclick="event.preventDefault(); selectAllOptions('filterFeature'); return false;">Select all</a>
                                </div>
                            </div>
                            <div class="multi-select-options" id="filterFeatureOptions"></div>
                        </div>
                    </div>
                </div>
                <div class="multi-select-wrapper">
                    <div class="date-filter-wrapper">
                        <div class="date-filter-display" onclick="toggleDateFilter()">
                            <span class="date-filter-text" id="dateFilterText">All Dates</span>
                            <span class="date-filter-arrow">‚ñº</span>
                        </div>
                        <div class="date-filter-dropdown" id="dateFilterDropdown">
                            <div class="date-filter-modes">
                                <button class="date-mode-btn active" data-mode="last" onclick="setDateFilterMode('last')">Last</button>
                                <button class="date-mode-btn" data-mode="since" onclick="setDateFilterMode('since')">Since</button>
                                <button class="date-mode-btn" data-mode="between" onclick="setDateFilterMode('between')">Between</button>
                            </div>
                            <div class="date-filter-content">
                                <div id="dateModeLastContent" class="date-mode-content active">
                                    <div class="date-preset-options">
                                        <button class="date-preset-btn" onclick="selectDatePreset(7)">Last 7 days</button>
                                        <button class="date-preset-btn" onclick="selectDatePreset(30)">Last 30 days</button>
                                        <button class="date-preset-btn" onclick="selectDatePreset(60)">Last 60 days</button>
                                    </div>
                                </div>
                                <div id="dateModeSinceContent" class="date-mode-content">
                                    <div class="date-input-group">
                                        <label>Since date:</label>
                                        <input type="date" id="sinceDateInput" class="date-input">
                                        <button class="date-apply-btn" onclick="applySinceDate()">Apply</button>
                                    </div>
                                </div>
                                <div id="dateModeBetweenContent" class="date-mode-content">
                                    <div class="date-input-group">
                                        <label>From:</label>
                                        <input type="date" id="fromDateInput" class="date-input">
                                    </div>
                                    <div class="date-input-group">
                                        <label>To:</label>
                                        <input type="date" id="toDateInput" class="date-input">
                                    </div>
                                    <button class="date-apply-btn" onclick="applyBetweenDates()">Apply</button>
                                </div>
                            </div>
                            <div class="date-filter-actions">
                                <button class="date-cancel-btn" onclick="cancelDateFilter()">Cancel</button>
                            </div>
                        </div>
                    </div>
                </div>
                <button class="filter-clear-btn" onclick="clearFilters()">Clear Filters</button>
            </div>
        </div>

        <div class="main-content" id="mainContent">
            <div class="sidebar">
                <div class="sidebar-section">
                    <h3>Category Views</h3>
                    <button class="view-btn active" data-view="level1">
                        <span class="view-btn-icon">üìä</span>
                        <span>Level 1 Distribution</span>
                    </button>
                    <button class="view-btn" data-view="level2">
                        <span class="view-btn-icon">üìà</span>
                        <span>Level 2 Distribution</span>
                    </button>
                </div>
                <div class="sidebar-section">
                    <h3>Analysis Views</h3>
                    <button class="view-btn" data-view="handwritten">
                        <span class="view-btn-icon">‚úçÔ∏è</span>
                        <span>Handwritten Text</span>
                    </button>
                    <button class="view-btn" data-view="imagetypes">
                        <span class="view-btn-icon">üñºÔ∏è</span>
                        <span>Image Types</span>
                    </button>
                    <button class="view-btn" data-view="scanphoto">
                        <span class="view-btn-icon">üì∑</span>
                        <span>Scan/Photo</span>
                    </button>
                    <button class="view-btn" data-view="languages">
                        <span class="view-btn-icon">üåê</span>
                        <span>Languages</span>
                    </button>
                    <button class="view-btn" data-view="personaldata">
                        <span class="view-btn-icon">üîí</span>
                        <span>Personal Data</span>
                    </button>
                </div>
                <div class="sidebar-section">
                    <h3>User Records</h3>
                    <button class="view-btn" data-view="userrecords">
                        <span class="view-btn-icon">üîç</span>
                        <span>User Browser</span>
                    </button>
                </div>
            </div>

            <div class="content-area">
                <div id="level1" class="view-panel active">
                    <div class="level-selector">
                        <button class="level-btn active" data-view="chart" onclick="switchLevel1View('chart')">Chart View</button>
                        <button class="level-btn" data-view="table" onclick="switchLevel1View('table')">Comparison Table</button>
                    </div>
                    
                    <div id="level1ChartView">
                        <div class="chart-container">
                            <div class="chart-wrapper">
                                <div class="chart-loader" id="chartLoader">
                                    <div class="chart-loader-spinner"></div>
                                    <div class="chart-loader-text" id="chartLoaderText">Loading data...</div>
                                    <div class="chart-loader-subtext" id="chartLoaderSubtext">Please wait</div>
                                </div>
                                <canvas id="level1PieChart"></canvas>
                                <div id="tooltip" class="tooltip"></div>
                                <div class="chart-stats-overlay">
                                    <div class="chart-stat-item">
                                        <strong>Total Records:</strong> <span id="totalRecords">-</span>
                                    </div>
                                    <div class="chart-stat-item">
                                        <strong>Level 1 Categories:</strong> <span id="level1Count">-</span>
                                    </div>
                                </div>
                            </div>
                            <div class="chart-legend" id="level1Legend">
                                <div class="legend-title">Categories</div>
                                <div id="level1LegendContent"></div>
                            </div>
                        </div>
                        <div class="category-list" id="level1List"></div>
                    </div>
                    
                    <div id="level1TableView" style="display: none;">
                        <div style="overflow-x: auto;">
                            <table class="data-table" id="level1ComparisonTable">
                                <thead>
                                    <tr>
                                        <th onclick="sortTable('rank')">Rank</th>
                                        <th onclick="sortTable('name')">Category</th>
                                        <th onclick="sortTable('count')">Count</th>
                                        <th onclick="sortTable('percentage')">% of Total</th>
                                        <th onclick="sortTable('level2')">Level 2 Cats</th>
                                        <th onclick="sortTable('handwritten')">Handwritten %</th>
                                        <th onclick="sortTable('personal')">Personal Data %</th>
                                        <th onclick="sortTable('scanphoto')">Scans/Photos %</th>
                                    </tr>
                                </thead>
                                <tbody id="level1TableBody"></tbody>
                            </table>
                        </div>
                    </div>
                </div>

                <!-- Detailed Stats Modal -->
                <div id="detailedStatsModal" class="modal-overlay">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h2 id="modalCategoryName">Category Details</h2>
                            <button class="modal-close" onclick="closeDetailedStats()">&times;</button>
                        </div>
                        <div class="modal-body" id="detailedStatsContent">
                            <!-- Content will be populated dynamically -->
                        </div>
                    </div>
                </div>

                <div id="level2" class="view-panel">
                    <div class="level-selector">
                        <select id="level1Selector" class="enhanced-dropdown">
                            <option value="">Select Level 1 Category...</option>
                        </select>
                    </div>
                    <div class="chart-container">
                        <div class="chart-wrapper">
                            <canvas id="level2PieChart"></canvas>
                            <div id="tooltip2" class="tooltip"></div>
                        </div>
                        <div class="chart-legend" id="level2Legend">
                            <div class="legend-title">Level 2 Categories</div>
                            <div id="level2LegendContent"></div>
                        </div>
                    </div>
                    <div class="category-list" id="level2List"></div>
                </div>

                <div id="handwritten" class="view-panel">
                    <h2 style="margin-bottom: 20px;">Handwritten Text Analysis by Category</h2>
                    <div class="category-list" id="handwrittenList"></div>
                </div>

                <div id="imagetypes" class="view-panel">
                    <div id="imageTypesList"></div>
                </div>

                <div id="scanphoto" class="view-panel">
                    <h2 style="margin-bottom: 20px;">Scan/Photo Analysis by Category</h2>
                    <div class="category-list" id="scanPhotoList"></div>
                </div>

                <div id="languages" class="view-panel">
                    <div class="level-selector">
                        <select id="languagesCategorySelector" class="enhanced-dropdown">
                            <option value="">All Categories</option>
                        </select>
                    </div>
                    <div class="category-list" id="languagesList"></div>
                </div>

                <div id="personaldata" class="view-panel">
                    <h2 style="margin-bottom: 20px;">Personal Data Analysis by Category</h2>
                    <div class="category-list" id="personalDataList"></div>
                </div>

                <div id="userrecords" class="view-panel">
                    <h2 style="margin-bottom: 20px;">User Records Browser</h2>
                    <div class="user-records-container">
                        <div class="user-search-section">
                            <div class="search-box">
                                <input type="text" id="userIdSearch" placeholder="Search by User ID..." class="user-search-input" onkeypress="if(event.key==='Enter') searchUserById()">
                                <button onclick="searchUserById()" class="search-btn">Search</button>
                            </div>
                        </div>
                        <div class="user-details" id="userDetails">
                            <div class="empty-user-state">Use search or apply filters to view user records</div>
                        </div>
                        <div class="user-navigation">
                            <button onclick="previousUser()" class="nav-btn" id="prevUserBtn" disabled>‚Üê Previous</button>
                            <span class="user-counter" id="userCounter">- / -</span>
                            <button onclick="nextUser()" class="nav-btn" id="nextUserBtn" disabled>Next ‚Üí</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Load saved state from localStorage
        function loadSavedState() {
            try {
                const saved = localStorage.getItem('analyzerState');
                if (saved) {
                    const state = JSON.parse(saved);
                    return state;
                }
            } catch (e) {
                console.warn('Could not load saved state:', e);
            }
            return null;
        }
        
        // Save current state to localStorage
        function saveState() {
            try {
                const state = {
                    currentProduct: currentProduct,
                    currentView: currentView,
                    activeFilters: activeFilters,
                    level1TableView: level1TableView,
                    level1TableSort: level1TableSort
                };
                localStorage.setItem('analyzerState', JSON.stringify(state));
            } catch (e) {
                console.warn('Could not save state:', e);
            }
        }
        
        let currentProduct = 'pdfguru';
        let currentData = null;
        let originalData = null; // Store original unfiltered data
        let currentView = 'level1';
        let hoveredSegment = null;
        let level1TableView = 'chart';
        let level1TableSort = 'count-desc';
        let handwrittenTableSort = 'percentage-desc';
        let scanPhotoTableSort = 'percentage-desc';
        let personalDataTableSort = 'percentage-desc';
        let imageTypesTableSort = 'count-desc';
        let extensionData = null;
        let allProductsExtensionData = {}; // Store extension data for all products
        let categoryColorMap = {}; // Global map: category names to their consistent colors across all products
        let colorMapInitialized = false; // Track if color map has been initialized based on popularity
        let allProductsUserMappings = {}; // Store user mappings for all products
        let userMappings = null;
        let filteredUserIds = null;
        let filteredUsersList = null;
        let currentUserIndex = -1;
        let activeFilters = {
            country: [],
            device: [],
            feature: []
        };
        let dateFilter = {
            type: null, // 'last', 'since', 'between', or null
            value: null // days for 'last', date string for 'since', {from, to} for 'between'
        };
        let multiSelectData = {
            filterCountry: [],
            filterDevice: [],
            filterFeature: []
        };
        
        // Notification functions
        function showNotification(message, type = 'error') {
            const notification = document.getElementById('notification');
            const messageEl = document.getElementById('notificationMessage');
            
            if (!notification || !messageEl) return;
            
            messageEl.textContent = message;
            notification.className = `notification ${type} show`;
            
            // Auto-hide after 5 seconds
            setTimeout(() => {
                hideNotification();
            }, 5000);
        }
        
        function hideNotification() {
            const notification = document.getElementById('notification');
            if (notification) {
                notification.classList.remove('show');
            }
        }
        
        // Country groups mapping
        const countryGroups = {
            'Brazil': ['Brazil'],
            'EU_UK_JP': [
                // All EU countries
                'Austria', 'Belgium', 'Bulgaria', 'Croatia', 'Cyprus', 'Czech Republic', 'Denmark',
                'Estonia', 'Finland', 'France', 'Germany', 'Greece', 'Hungary', 'Ireland', 'Italy',
                'Latvia', 'Lithuania', 'Luxembourg', 'Malta', 'Netherlands', 'Poland', 'Portugal',
                'Romania', 'Slovakia', 'Slovenia', 'Spain', 'Sweden',
                // UK and Japan
                'United Kingdom', 'Japan'
            ],
            'IMEA': [
                'India', 'United Arab Emirates', 'Saudi Arabia', 'Israel', 'South Africa', 'Egypt',
                'Turkey', 'Iran', 'Iraq', 'Kuwait', 'Qatar', 'Oman', 'Bahrain', 'Jordan', 'Lebanon',
                'Pakistan', 'Bangladesh', 'Sri Lanka', 'Nepal', 'Kenya', 'Nigeria', 'Ghana', 'Morocco',
                'Tunisia', 'Algeria', 'Ethiopia', 'Tanzania', 'Uganda'
            ],
            'India': ['India'],
            'Latam': [
                'Argentina', 'Brazil', 'Chile', 'Colombia', 'Mexico', 'Peru', 'Venezuela',
                'Ecuador', 'Guatemala', 'Cuba', 'Haiti', 'Dominican Republic', 'Honduras',
                'Paraguay', 'Nicaragua', 'El Salvador', 'Costa Rica', 'Panama', 'Uruguay',
                'Bolivia', 'Trinidad and Tobago', 'Jamaica', 'Guyana', 'Suriname'
            ],
            'Tier 1': [
                'United States', 'United Kingdom', 'Australia', 'Canada'
            ],
            'WorldWide': [] // Will be populated with all countries
        };

        // Load products index
        async function loadProductsIndex() {
            try {
                const response = await fetch('products_index.json');
                if (response.ok) {
                    const index = await response.json();
                    return index;
                }
            } catch (error) {
                console.warn('Could not load products index');
            }
            return { products: ['pdfguru'], product_info: {} };
        }

        function showLoader(text = 'Loading...', subtext = null) {
            const chartLoader = document.getElementById('chartLoader');
            const chartLoaderText = document.getElementById('chartLoaderText');
            const chartLoaderSubtext = document.getElementById('chartLoaderSubtext');
            
            if (chartLoader) {
                chartLoader.classList.add('active');
            }
            if (chartLoaderText) {
                chartLoaderText.textContent = text;
            }
            if (chartLoaderSubtext && subtext) {
                chartLoaderSubtext.textContent = subtext;
            }
        }

        function hideLoader() {
            const chartLoader = document.getElementById('chartLoader');
            if (chartLoader) {
                chartLoader.classList.remove('active');
            }
        }

        // Load product data
        async function loadProductData(productName) {
            try {
                // Don't clear categoryColorMap or colorMapInitialized - we want colors to be consistent across products
                // Colors are assigned based on popularity from the first product loaded
                
                // Update loader text
                const chartLoaderText = document.getElementById('chartLoaderText');
                const chartLoaderSubtext = document.getElementById('chartLoaderSubtext');
                if (chartLoaderText) chartLoaderText.textContent = 'Loading analysis data...';
                if (chartLoaderSubtext) chartLoaderSubtext.textContent = 'Fetching product statistics...';
                
                const response = await fetch(`${productName}_analysis.json`);
                
                if (!response.ok) {
                    console.error(`HTTP error! status: ${response.status} for ${productName}_analysis.json`);
                    showEmptyState(`Could not load ${productName}_analysis.json (HTTP ${response.status})`);
                    return null;
                }
                
                const data = await response.json();
                
                if (!data || !data.level1_distribution) {
                    console.error(`Invalid data structure for ${productName}`);
                    showEmptyState(`Invalid data structure for ${productName}`);
                    return null;
                }
                
                currentData = data;
                originalData = data; // Store original data for filtering
                
                // Save current filter state before loading new product data
                const savedFilters = {
                    country: [...activeFilters.country],
                    device: [...activeFilters.device],
                    feature: [...activeFilters.feature]
                };
                const savedDateFilter = { ...dateFilter };
                
                // Reset extension data and user mappings (will be reloaded for new product)
                extensionData = {};
                userMappings = {};
                filteredUserIds = null;
                
                // Update loader text
                if (chartLoaderText) chartLoaderText.textContent = 'Loading extension data...';
                if (chartLoaderSubtext) chartLoaderSubtext.textContent = 'Processing user attributes...';
                
                // Load extension data for new product
                await loadExtensionData(productName);
                
                // After loading extension data, validate and restore filters
                // Remove filter values that are not available for the new product
                const availableCountries = new Set(multiSelectData.filterCountry || []);
                const availableDevices = new Set(multiSelectData.filterDevice || []);
                const availableFeatures = new Set(multiSelectData.filterFeature || []);
                
                activeFilters = {
                    country: savedFilters.country.filter(c => availableCountries.has(c)),
                    device: savedFilters.device.filter(d => availableDevices.has(d)),
                    feature: savedFilters.feature.filter(f => availableFeatures.has(f))
                };
                
                // Restore date filter
                dateFilter = savedDateFilter;
                
                // Update filter UI to reflect current selections
                updateMultiSelectDisplay('filterCountry', 'country');
                updateMultiSelectDisplay('filterDevice', 'device');
                updateMultiSelectDisplay('filterFeature', 'feature');
                updateDateFilterDisplay();
                
                // Update loader text
                if (chartLoaderText) chartLoaderText.textContent = 'Preparing interface...';
                if (chartLoaderSubtext) chartLoaderSubtext.textContent = 'Almost ready...';
                
                // Ensure filters bar is visible
                const filtersBar = document.getElementById('filtersBar');
                if (filtersBar) {
                    filtersBar.style.display = 'flex';
                }
                
                updateUI();
                
                // Update filter UI checkboxes to reflect current selections
                // This needs to happen after updateUI() which populates the dropdowns
                setTimeout(() => {
                    // Update checkboxes for country filter
                    document.querySelectorAll('#filterCountry .multi-select-option').forEach(opt => {
                        const value = opt.getAttribute('data-value');
                        const checkbox = opt.querySelector('input[type="checkbox"]');
                        if (checkbox && value) {
                            checkbox.checked = activeFilters.country.includes(value);
                            if (checkbox.checked) {
                                opt.classList.add('selected');
                            } else {
                                opt.classList.remove('selected');
                            }
                        }
                    });
                    
                    // Update checkboxes for device filter
                    document.querySelectorAll('#filterDevice .multi-select-option').forEach(opt => {
                        const value = opt.getAttribute('data-value');
                        const checkbox = opt.querySelector('input[type="checkbox"]');
                        if (checkbox && value) {
                            checkbox.checked = activeFilters.device.includes(value);
                            if (checkbox.checked) {
                                opt.classList.add('selected');
                            } else {
                                opt.classList.remove('selected');
                            }
                        }
                    });
                    
                    // Update checkboxes for feature filter
                    document.querySelectorAll('#filterFeature .multi-select-option').forEach(opt => {
                        const value = opt.getAttribute('data-value');
                        const checkbox = opt.querySelector('input[type="checkbox"]');
                        if (checkbox && value) {
                            checkbox.checked = activeFilters.feature.includes(value);
                            if (checkbox.checked) {
                                opt.classList.add('selected');
                            } else {
                                opt.classList.remove('selected');
                            }
                        }
                    });
                    
                    // Update filter display text
                    updateMultiSelectDisplay('filterCountry', 'country');
                    updateMultiSelectDisplay('filterDevice', 'device');
                    updateMultiSelectDisplay('filterFeature', 'feature');
                    updateDateFilterDisplay();
                    
                    // Reapply filters if any are active
                    if (activeFilters.country.length > 0 || activeFilters.device.length > 0 || activeFilters.feature.length > 0 || dateFilter.type) {
                        applyFilters();
                    } else {
                        // Ensure view is updated after data is loaded
                        updateView();
                    }
                }, 100);
                
                // Hide loader after UI is updated
                hideLoader();
                
                return data;
            } catch (error) {
                console.error(`Error loading ${productName}:`, error);
                console.error('Error details:', {
                    name: error.name,
                    message: error.message,
                    stack: error.stack
                });
                showEmptyState(`Error loading ${productName}: ${error.message}. Make sure the JSON file exists and you're opening the HTML file from the same directory, or use a local web server.`);
            }
            return null;
        }

        function showEmptyState(message = 'No data available for this product') {
            const isFileProtocol = window.location.protocol === 'file:';
            const helpText = isFileProtocol 
                ? `<br><br><strong>‚ö†Ô∏è CORS Issue Detected</strong><br>
                   You're opening the file directly. Please use a local web server:<br><br>
                   <code style="background: #f0f0f0; padding: 5px; border-radius: 4px;">
                   cd ~/Documents && python3 start_server.py
                   </code><br><br>
                   Or open the browser console (F12) for more details.`
                : '<br><br>Check the browser console (F12) for more details.';
            
            document.querySelectorAll('.view-panel').forEach(panel => {
                if (panel.classList.contains('active')) {
                    // Check if panel has structure (like level1ChartView)
                    const hasStructure = panel.querySelector('#level1ChartView') || panel.querySelector('#level2ChartView');
                    
                    if (hasStructure) {
                        // If panel has structure, only clear the content and show empty state
                        const level1ChartView = panel.querySelector('#level1ChartView');
                        const level2ChartView = panel.querySelector('#level2ChartView');
                        const chartView = level1ChartView || level2ChartView;
                        
                        if (chartView) {
                            // Clear chart content but keep structure
                            chartView.innerHTML = `<div class="empty-state">${message}${helpText}</div>`;
                        }
                    } else {
                        // If no structure, replace entire panel (for other views)
                        panel.innerHTML = `<div class="empty-state">${message}${helpText}</div>`;
                    }
                }
            });
        }
        
        function clearEmptyState() {
            // Clear empty state by restoring the view panel structure
            // This will be handled by updateView() which will re-render the content
            // We just need to ensure the panel is ready for new content
            document.querySelectorAll('.view-panel').forEach(panel => {
                if (panel.classList.contains('active')) {
                    const emptyState = panel.querySelector('.empty-state');
                    if (emptyState) {
                        // Don't clear the entire panel, just mark it for re-rendering
                        // updateView() will handle the actual rendering
                    }
                }
            });
        }

        // Load from merged CSV file (for all products)
        async function loadFromMergedFile(response, userMappingFile = null) {
            const text = await response.text();
            const lines = text.split('\n').filter(l => l.trim());
            
            // Parse CSV properly
            function parseCSVLine(line) {
                const result = [];
                let current = '';
                let inQuotes = false;
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        result.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                result.push(current.trim());
                return result;
            }
            
            if (lines.length === 0) return;
            
            const headers = parseCSVLine(lines[0]);
            const user_idIdx = headers.indexOf('user_id');
            const countryIdx = headers.indexOf('country');
            const deviceIdx = headers.indexOf('device');
            const featureIdx = headers.indexOf('gp:feature');
            const emailIdx = headers.indexOf('gp:email');
            
            // Try multiple possible column names for trial date
            let trialDateIdx = headers.indexOf('subscription_started_at');
            if (trialDateIdx < 0) {
                trialDateIdx = headers.indexOf('trial_date');
            }
            if (trialDateIdx < 0) {
                trialDateIdx = headers.indexOf('trialDate');
            }
            if (trialDateIdx < 0) {
                trialDateIdx = headers.indexOf('subscription_started');
            }
            
            // Log column indices for debugging
            console.log('CSV Headers:', headers);
            console.log('Trial date column index:', trialDateIdx, 'Column name:', trialDateIdx >= 0 ? headers[trialDateIdx] : 'NOT FOUND');
            
            // If trial date column not found, show all columns that might contain dates
            if (trialDateIdx < 0) {
                console.warn('Trial date column not found! Searching for date-like columns...');
                const dateLikeColumns = headers.filter((h, idx) => {
                    const lower = h.toLowerCase();
                    return lower.includes('date') || lower.includes('time') || lower.includes('start') || lower.includes('trial') || lower.includes('subscription');
                });
                if (dateLikeColumns.length > 0) {
                    console.warn('Found potential date columns:', dateLikeColumns);
                } else {
                    console.warn('No date-like columns found in CSV headers');
                }
            }
            
            extensionData = {};
            const countries = new Set();
            const devices = new Set();
            const features = new Set();
            const featureCounts = new Map();
            const deviceCounts = new Map();
            let usersWithTrialDates = 0;
            
            for (let i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue;
                const values = parseCSVLine(lines[i]);
                if (values.length <= user_idIdx) continue;
                
                const userId = values[user_idIdx]?.trim();
                if (!userId) continue;
                
                // If user already exists, only update if this row has a trial date and previous didn't
                // This handles multiple records per user - keep the first trial date found
                if (extensionData[userId] && extensionData[userId].trialDate) {
                    // User already has a trial date, skip this row to avoid overwriting
                    continue;
                }
                
                const country = countryIdx >= 0 && values[countryIdx] ? (values[countryIdx].trim() || '') : '';
                const device = deviceIdx >= 0 && values[deviceIdx] ? (values[deviceIdx].trim() || '') : '';
                const feature = featureIdx >= 0 && values[featureIdx] ? (values[featureIdx].trim() || '') : '';
                const email = emailIdx >= 0 && values[emailIdx] ? (values[emailIdx].trim() || '') : '';
                
                // Parse trial date from subscription_started_at or other date columns
                let trialDate = null;
                if (trialDateIdx >= 0 && values.length > trialDateIdx && values[trialDateIdx]) {
                    const dateStr = values[trialDateIdx].trim();
                    if (dateStr && dateStr !== 'null' && dateStr !== '' && dateStr !== 'None' && dateStr !== 'NULL') {
                        // Try multiple date formats
                        let dateStrToParse = dateStr;
                        
                        // Handle different date formats
                        // Format 1: '2025-12-12 01:43:41' (space separator)
                        if (dateStr.includes(' ') && !dateStr.includes('T')) {
                            dateStrToParse = dateStr.replace(' ', 'T');
                        }
                        // Format 2: '2025-12-12T01:43:41' (already ISO)
                        // Format 3: '2025-12-12' (date only)
                        // Format 4: Unix timestamp (numeric string)
                        else if (/^\d+$/.test(dateStr)) {
                            // Unix timestamp in seconds or milliseconds
                            const timestamp = parseInt(dateStr);
                            dateStrToParse = timestamp < 10000000000 
                                ? new Date(timestamp * 1000).toISOString() // seconds
                                : new Date(timestamp).toISOString(); // milliseconds
                        }
                        
                        trialDate = new Date(dateStrToParse);
                        if (isNaN(trialDate.getTime())) {
                            // Try parsing as-is
                            trialDate = new Date(dateStr);
                            if (isNaN(trialDate.getTime())) {
                                // Try with different separators
                                const dateStrAlt = dateStr.replace(/\//g, '-');
                                trialDate = new Date(dateStrAlt);
                                if (isNaN(trialDate.getTime())) {
                                    trialDate = null;
                                }
                            }
                        }
                        
                        if (trialDate && !isNaN(trialDate.getTime())) {
                            // Validate date is reasonable (between 2000 and 2100)
                            const year = trialDate.getFullYear();
                            if (year < 2000 || year > 2100) {
                                trialDate = null;
                            } else {
                                usersWithTrialDates++;
                            }
                        } else {
                            trialDate = null;
                        }
                    }
                }
                
                extensionData[userId] = {
                    country: country || 'none',
                    device: device || 'none',
                    feature: feature || 'none',
                    email: email || '',
                    firstSeenDate: null,
                    trialDate: trialDate,
                    amplitudeId: null
                };
                
                // Add to sets
                countries.add(country || 'none');
                if (device) {
                    devices.add(device || 'none');
                    deviceCounts.set(device, (deviceCounts.get(device) || 0) + 1);
                }
                if (feature) {
                    features.add(feature || 'none');
                    featureCounts.set(feature, (featureCounts.get(feature) || 0) + 1);
                }
            }
            
            // Populate dropdowns
            function sortWithNone(arr) {
                return arr.sort((a, b) => {
                    if (a === 'none') return 1;
                    if (b === 'none') return -1;
                    return a.localeCompare(b);
                });
            }
            
            const allCountries = sortWithNone(Array.from(countries));
            multiSelectData.filterCountry = allCountries;
            countryGroups.WorldWide = allCountries.filter(c => c !== 'none');
            populateMultiSelectWithGroups('filterCountry', allCountries);
            updateMultiSelectDisplay('filterCountry', 'country');
            
            // Device filter
            if (devices.size > 0) {
                const deviceArray = Array.from(devices).filter(d => d && d !== 'none');
                const sortedDevices = deviceArray.sort((a, b) => {
                    const countA = deviceCounts.get(a) || 0;
                    const countB = deviceCounts.get(b) || 0;
                    if (countB !== countA) return countB - countA;
                    return a.localeCompare(b);
                });
                multiSelectData.filterDevice = [...sortedDevices, 'none'];
                populateMultiSelect('filterDevice', multiSelectData.filterDevice);
            } else {
                multiSelectData.filterDevice = ['none'];
                populateMultiSelect('filterDevice', multiSelectData.filterDevice);
            }
            document.getElementById('filterDeviceWrapper').style.display = 'block';
            
            // Feature filter
            if (features.size > 0) {
                const featureArray = Array.from(features).filter(f => f && f !== 'none');
                const sortedFeatures = featureArray.sort((a, b) => {
                    const countA = featureCounts.get(a) || 0;
                    const countB = featureCounts.get(b) || 0;
                    if (countB !== countA) return countB - countA;
                    return a.localeCompare(b);
                });
                multiSelectData.filterFeature = [...sortedFeatures, 'none'];
                populateMultiSelect('filterFeature', multiSelectData.filterFeature);
            } else {
                multiSelectData.filterFeature = ['none'];
                populateMultiSelect('filterFeature', multiSelectData.filterFeature);
            }
            document.getElementById('filterFeatureWrapper').style.display = 'block';
            
            // Log statistics - count unique users with trial dates
            const totalUsers = Object.keys(extensionData).length;
            let usersWithTrialDatesCount = 0;
            for (const userId in extensionData) {
                if (extensionData[userId].trialDate) {
                    usersWithTrialDatesCount++;
                }
            }
            console.log(`Loaded from merged file: ${totalUsers} unique users, ${usersWithTrialDatesCount} with trial dates (${totalUsers > 0 ? (usersWithTrialDatesCount/totalUsers*100).toFixed(1) : 0}%)`);
            
            // Debug: Show sample trial dates and sample rows without dates
            let sampleCount = 0;
            let sampleNoDateCount = 0;
            for (const userId in extensionData) {
                if (extensionData[userId].trialDate && sampleCount < 5) {
                    const date = extensionData[userId].trialDate;
                    console.log(`Sample trial date for ${userId.substring(0, 8)}...: ${date} (${date instanceof Date ? 'Date object' : typeof date})`);
                    sampleCount++;
                } else if (!extensionData[userId].trialDate && sampleNoDateCount < 3) {
                    // Show sample rows that don't have trial dates for debugging
                    console.log(`Sample user without trial date: ${userId.substring(0, 8)}... (country: ${extensionData[userId].country}, device: ${extensionData[userId].device})`);
                    sampleNoDateCount++;
                }
            }
            
            // Debug: Show sample raw date values from CSV if no dates were parsed
            if (usersWithTrialDatesCount === 0 && lines.length > 1) {
                console.warn('No trial dates found. Showing sample raw date values from CSV:');
                console.warn(`Trial date column index: ${trialDateIdx}, Column name: ${trialDateIdx >= 0 ? headers[trialDateIdx] : 'NOT FOUND'}`);
                console.warn('All available columns:', headers);
                
                for (let i = 1; i < Math.min(6, lines.length); i++) {
                    if (!lines[i].trim()) continue;
                    const values = parseCSVLine(lines[i]);
                    if (trialDateIdx >= 0 && values.length > trialDateIdx) {
                        const rawDateValue = values[trialDateIdx];
                        console.log(`  Row ${i}, column ${trialDateIdx} (${headers[trialDateIdx]}): "${rawDateValue}"`);
                    } else if (trialDateIdx < 0) {
                        // If column not found, show all columns to help identify the date column
                        console.log(`  Row ${i} - All values:`, values.slice(0, 10)); // Show first 10 columns
                    }
                }
            }
            
            // Load user mappings (still needed for filtering)
            // userMappingFile is passed as parameter
            if (userMappingFile) {
                const mappingResponse = await fetch(userMappingFile);
                if (mappingResponse.ok) {
                    userMappings = await mappingResponse.json();
                }
            }
        }
        
        // Load extension data and user mappings
        async function loadExtensionData(productName = 'pdfguru') {
            try {
                // Try to load from merged file first for all products
                let mergedFile = null;
                let userMappingFile = null;
                
                if (productName === 'pdfguru') {
                    mergedFile = 'guru_merged_full.csv';
                    userMappingFile = 'pdfguru_user_mappings.json';
                } else if (productName === 'pdfleader') {
                    mergedFile = 'leader_merged_full.csv';
                    userMappingFile = 'pdfleader_user_mappings.json';
                } else if (productName === 'thebestpdf') {
                    mergedFile = 'best_merged_full.csv';
                    userMappingFile = 'thebestpdf_user_mappings.json';
                }
                
                if (mergedFile) {
                    try {
                        const mergedResponse = await fetch(mergedFile);
                        if (mergedResponse.ok) {
                            console.log(`Loading ${productName} data from merged file: ${mergedFile}...`);
                            await loadFromMergedFile(mergedResponse, userMappingFile);
                            return;
                        } else {
                            console.warn(`Merged file ${mergedFile} not found (HTTP ${mergedResponse.status}). Falling back to separate files.`);
                        }
                    } catch (e) {
                        console.warn(`Could not load merged file ${mergedFile} for ${productName}, falling back to separate files:`, e);
                    }
                }
                
                // Fallback to old logic if merged file not found
                
                // Fall back to separate files (original method for other products)
                // Load extension data (CSV) - product-specific
                const extFile = `${productName}_matched_extension_data.csv`;
                const extResponse = await fetch(extFile);
                if (!extResponse.ok) {
                    console.warn(`Extension data not available for ${productName}. Status: ${extResponse.status}`);
                    // Keep filters bar visible even if extension data is not available
                    const filtersBar = document.getElementById('filtersBar');
                    if (filtersBar) {
                        filtersBar.style.display = 'flex';
                    }
                    return;
                }
                
                const extText = await extResponse.text();
                const extLines = extText.split('\n').filter(l => l.trim());
                
                // Parse CSV properly (handle quoted values)
                function parseCSVLine(line) {
                    const result = [];
                    let current = '';
                    let inQuotes = false;
                    
                    for (let i = 0; i < line.length; i++) {
                        const char = line[i];
                        if (char === '"') {
                            inQuotes = !inQuotes;
                        } else if (char === ',' && !inQuotes) {
                            result.push(current.trim());
                            current = '';
                        } else {
                            current += char;
                        }
                    }
                    result.push(current.trim());
                    return result;
                }
                
                const extHeaders = parseCSVLine(extLines[0]);
                
                const countryIdx = extHeaders.indexOf('country');
                const deviceIdx = extHeaders.indexOf('device');
                const featureIdx = extHeaders.indexOf('gp:feature');
                const emailIdx = extHeaders.indexOf('gp:email');
                const userIdIdx = extHeaders.indexOf('user_id');
                const amplitudeIdIdx = extHeaders.indexOf('amplitude_id');
                const firstUseIdx = extHeaders.indexOf('first use');
                
                // Check which columns are available
                const hasDevice = deviceIdx >= 0;
                const hasFeature = featureIdx >= 0;
                
                
                extensionData = {};
                const countries = new Set();
                const devices = new Set();
                const features = new Set();
                const featureCounts = new Map(); // Track feature popularity
                const deviceCounts = new Map(); // Track device popularity
                
                for (let i = 1; i < extLines.length; i++) {
                    if (!extLines[i].trim()) continue;
                    const values = parseCSVLine(extLines[i]);
                    if (values.length <= userIdIdx) continue;
                    
                    const userId = values[userIdIdx]?.trim();
                    if (!userId) continue;
                    
                    const country = countryIdx >= 0 && values[countryIdx] ? (values[countryIdx].trim() || '') : '';
                    const device = hasDevice && deviceIdx >= 0 && values[deviceIdx] !== undefined ? (values[deviceIdx].trim() || '') : '';
                    const feature = hasFeature && featureIdx >= 0 && values[featureIdx] !== undefined ? (values[featureIdx].trim() || '') : '';
                    const email = emailIdx >= 0 && values[emailIdx] ? (values[emailIdx].trim() || '') : '';
                    const amplitudeId = amplitudeIdIdx >= 0 && values[amplitudeIdIdx] ? values[amplitudeIdIdx].trim() : '';
                    const firstUse = firstUseIdx >= 0 && values[firstUseIdx] ? values[firstUseIdx].trim() : '';
                    
                    // Convert amplitude_id to date if it's a timestamp, or use first use date
                    let firstSeenDate = null;
                    if (firstUse) {
                        firstSeenDate = new Date(firstUse);
                        if (isNaN(firstSeenDate.getTime())) {
                            firstSeenDate = null;
                        }
                    } else if (amplitudeId && /^\d+$/.test(amplitudeId)) {
                        // Amplitude ID is a timestamp - validate it's reasonable
                        const timestamp = parseInt(amplitudeId);
                        // Unix timestamp range: 946684800000 (2000-01-01) to 4102444800000 (2100-01-01)
                        if (timestamp >= 946684800000 && timestamp <= 4102444800000) {
                            // It's in milliseconds and in valid range
                            firstSeenDate = new Date(timestamp);
                        } else if (timestamp >= 946684800 && timestamp <= 4102444800) {
                            // It's in seconds, convert to milliseconds
                            firstSeenDate = new Date(timestamp * 1000);
                        }
                    }
                    
                    // Validate date - must be between 2000 and 2100 (reasonable range)
                    if (firstSeenDate) {
                        const year = firstSeenDate.getFullYear();
                        if (year < 2000 || year > 2100) {
                            // Invalid date - too far in past or future
                            firstSeenDate = null;
                        }
                    }
                    
                    // Trial dates come from merged file for PDF Guru, not from separate file
                    let trialDate = null;
                    
                    extensionData[userId] = {
                        country: country || 'none',
                        device: device || 'none',
                        feature: feature || 'none',
                        email: email || '',
                        firstSeenDate: firstSeenDate,
                        trialDate: trialDate,
                        amplitudeId: amplitudeId // Store for reference
                    };
                    
                    // Add values to sets (including 'none' for empty values)
                    countries.add(country || 'none');
                    if (hasDevice && deviceIdx >= 0 && values.length > deviceIdx) {
                        const deviceValue = values[deviceIdx] ? values[deviceIdx].trim() : '';
                        const finalDevice = deviceValue || 'none';
                        devices.add(finalDevice);
                        // Count device popularity
                        deviceCounts.set(finalDevice, (deviceCounts.get(finalDevice) || 0) + 1);
                    }
                    if (hasFeature && featureIdx >= 0 && values.length > featureIdx) {
                        const featureValue = values[featureIdx] ? values[featureIdx].trim() : '';
                        const finalFeature = featureValue || 'none';
                        features.add(finalFeature);
                        // Count feature popularity
                        featureCounts.set(finalFeature, (featureCounts.get(finalFeature) || 0) + 1);
                    }
                }
                
                // Load user mappings - product-specific
                const mappingFile = `${productName}_user_mappings.json`;
                const mappingResponse = await fetch(mappingFile);
                if (mappingResponse.ok) {
                    userMappings = await mappingResponse.json();
                } else {
                    console.warn(`User mappings not available for ${productName}`);
                }
                
                // Helper function to sort with 'none' at the end
                function sortWithNone(arr) {
                    return arr.sort((a, b) => {
                        if (a === 'none') return 1;
                        if (b === 'none') return -1;
                        return a.localeCompare(b);
                    });
                }
                
                // Log matching statistics
                const totalUsers = Object.keys(extensionData).length;
                let usersWithTrialDates = 0;
                for (const userId in extensionData) {
                    if (extensionData[userId].trialDate) {
                        usersWithTrialDates++;
                    }
                }
                console.log(`Extension data loaded: ${totalUsers} users, ${usersWithTrialDates} with trial dates (${totalUsers > 0 ? (usersWithTrialDates/totalUsers*100).toFixed(1) : 0}%)`);
                
                // Populate multi-select dropdowns (only if columns exist)
                const allCountries = sortWithNone(Array.from(countries));
                multiSelectData.filterCountry = allCountries;
                
                // Update WorldWide group to include all countries
                countryGroups.WorldWide = allCountries.filter(c => c !== 'none');
                
                // Populate country dropdown with groups first, then individual countries
                populateMultiSelectWithGroups('filterCountry', allCountries);
                updateMultiSelectDisplay('filterCountry', 'country');
                
                // Always show device and feature filters, but populate only if data exists
                
                // Always show device filter - sorted by popularity
                if (hasDevice && deviceIdx >= 0 && devices.size > 0) {
                    const deviceArray = Array.from(devices).filter(d => d && d !== 'none');
                    if (deviceArray.length > 0) {
                        // Sort by popularity (most popular first), then alphabetically, with 'none' at the end
                        const sortedDevices = deviceArray.sort((a, b) => {
                            const countA = deviceCounts.get(a) || 0;
                            const countB = deviceCounts.get(b) || 0;
                            if (countB !== countA) {
                                return countB - countA; // Most popular first
                            }
                            return a.localeCompare(b); // Alphabetically if same count
                        });
                        multiSelectData.filterDevice = [...sortedDevices, 'none'];
                        populateMultiSelect('filterDevice', multiSelectData.filterDevice);
                    } else {
                        multiSelectData.filterDevice = ['none'];
                        populateMultiSelect('filterDevice', multiSelectData.filterDevice);
                    }
                } else {
                    // Show empty filter with just 'none' option
                    multiSelectData.filterDevice = ['none'];
                    populateMultiSelect('filterDevice', multiSelectData.filterDevice);
                }
                updateMultiSelectDisplay('filterDevice', 'device');
                document.getElementById('filterDeviceWrapper').style.display = 'block';
                
                // Always show feature filter - sorted by popularity
                if (hasFeature && featureIdx >= 0 && features.size > 0) {
                    const featureArray = Array.from(features).filter(f => f && f !== 'none');
                    if (featureArray.length > 0) {
                        // Sort features by popularity (most popular first)
                        featureArray.sort((a, b) => {
                            const countA = featureCounts.get(a) || 0;
                            const countB = featureCounts.get(b) || 0;
                            return countB - countA; // Descending order (most popular first)
                        });
                        multiSelectData.filterFeature = featureArray;
                        populateMultiSelect('filterFeature', multiSelectData.filterFeature);
                    } else {
                        multiSelectData.filterFeature = ['none'];
                        populateMultiSelect('filterFeature', multiSelectData.filterFeature);
                    }
                } else {
                    // Show empty filter with just 'none' option
                    multiSelectData.filterFeature = ['none'];
                    populateMultiSelect('filterFeature', multiSelectData.filterFeature);
                }
                updateMultiSelectDisplay('filterFeature', 'feature');
                document.getElementById('filterFeatureWrapper').style.display = 'block';
                
                // Restore saved filters after populating dropdowns
                const savedState = loadSavedState();
                if (savedState && savedState.activeFilters) {
                    activeFilters = savedState.activeFilters;
                    // Update checkboxes and display
                    updateMultiSelectDisplay('filterCountry', 'country');
                    updateMultiSelectDisplay('filterDevice', 'device');
                    updateMultiSelectDisplay('filterFeature', 'feature');
                    
                    // Update checkboxes in options
                    ['filterCountry', 'filterDevice', 'filterFeature'].forEach(selectId => {
                        const filterKey = selectId.replace('filter', '').toLowerCase();
                        const selected = activeFilters[filterKey] || [];
                        const options = document.querySelectorAll(`#${selectId}Options .multi-select-option`);
                        options.forEach(option => {
                            const checkbox = option.querySelector('input[type="checkbox"]');
                            const label = option.querySelector('.multi-select-option-label');
                            if (checkbox && label) {
                                const value = label.textContent;
                                checkbox.checked = selected.includes(value);
                                option.classList.toggle('selected', selected.includes(value));
                            }
                        });
                    });
                    
                    // Apply filters if any are active
                    if (activeFilters.country.length > 0 || activeFilters.device.length > 0 || activeFilters.feature.length > 0) {
                        applyFilters();
                    }
                }
                
                
                const filtersBar = document.getElementById('filtersBar');
                if (filtersBar) {
                    filtersBar.style.display = 'flex';
                } else {
                    console.error('Filters bar element not found!');
                }
            } catch (error) {
                console.warn('Could not load extension data:', error);
                // Keep filters bar visible even if there's an error
                const filtersBar = document.getElementById('filtersBar');
                if (filtersBar) {
                    filtersBar.style.display = 'flex';
                }
            }
        }
        
        function populateMultiSelect(selectId, values) {
            const optionsContainer = document.getElementById(selectId + 'Options');
            if (!optionsContainer) {
                console.error('Options container not found:', selectId + 'Options');
                return;
            }
            
            optionsContainer.innerHTML = '';
            
            if (!values || values.length === 0) {
                console.warn('No values to populate for:', selectId);
                return;
            }
            
            values.forEach(value => {
                if (!value || value.trim() === '') return;
                
                const option = document.createElement('div');
                option.className = 'multi-select-option';
                const safeId = value.replace(/[^a-zA-Z0-9]/g, '_').replace(/'/g, '');
                const safeValue = value.replace(/'/g, "\\'");
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `${selectId}_${safeId}`;
                checkbox.onchange = function() {
                    toggleFilterOption(selectId, value);
                };
                
                const label = document.createElement('label');
                label.className = 'multi-select-option-label';
                label.htmlFor = `${selectId}_${safeId}`;
                label.textContent = value;
                
                option.appendChild(checkbox);
                option.appendChild(label);
                optionsContainer.appendChild(option);
            });
            
        }
        
        function toggleMultiSelect(selectId) {
            const wrapper = document.getElementById(selectId + 'Wrapper');
            const isActive = wrapper.classList.contains('active');
            
            // Close all other multi-selects
            document.querySelectorAll('.multi-select').forEach(ms => {
                ms.classList.remove('active');
            });
            
            // Toggle current
            if (!isActive) {
                wrapper.classList.add('active');
            }
        }
        
        function filterMultiSelect(selectId, searchTerm) {
            const options = document.querySelectorAll(`#${selectId}Options .multi-select-option`);
            const term = searchTerm.toLowerCase();
            
            options.forEach(option => {
                const label = option.querySelector('.multi-select-option-label').textContent.toLowerCase();
                option.style.display = label.includes(term) ? 'flex' : 'none';
            });
        }
        
        function toggleFilterOption(selectId, value) {
            const filterKey = selectId.replace('filter', '').toLowerCase();
            const index = activeFilters[filterKey].indexOf(value);
            
            if (index > -1) {
                activeFilters[filterKey].splice(index, 1);
            } else {
                activeFilters[filterKey].push(value);
            }
            
            // Update country group checkboxes if this is a country filter
            if (selectId === 'filterCountry') {
                updateCountryGroupCheckboxes();
            }
            
            updateMultiSelectDisplay(selectId, filterKey);
            applyFilters();
        }
        
        function updateMultiSelectDisplay(selectId, filterKey) {
            const display = document.querySelector(`#${selectId}Wrapper .multi-select-text`);
            const selected = activeFilters[filterKey];
            
            // Plural forms for filter keys
            const pluralForms = {
                'country': 'Countries',
                'device': 'Devices',
                'feature': 'Features'
            };
            
            if (selected.length === 0) {
                display.textContent = `All ${pluralForms[filterKey] || filterKey.charAt(0).toUpperCase() + filterKey.slice(1) + 's'}`;
            } else if (selected.length === 1) {
                display.textContent = selected[0];
            } else {
                display.textContent = `${selected.length} selected`;
            }
            
            // Update selected values section (only show if items are selected)
            const selectedContainer = document.getElementById(selectId + 'Selected');
            const selectedHeader = document.getElementById(selectId + 'SelectedHeader');
            const divider = document.getElementById(selectId + 'Divider');
            
            if (selectedContainer) {
                selectedContainer.innerHTML = '';
                
                if (selected.length > 0) {
                    // Show selected section
                    if (selectedHeader) selectedHeader.style.display = 'flex';
                    if (divider) divider.style.display = 'block';
                    selectedContainer.style.display = 'block';
                    
                    selected.forEach(value => {
                        const selectedItem = document.createElement('div');
                        selectedItem.className = 'multi-select-option selected';
                        const safeId = value.replace(/[^a-zA-Z0-9]/g, '_').replace(/'/g, '');
                        const safeValue = value.replace(/'/g, "\\'");
                        
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.id = `${selectId}_selected_${safeId}`;
                        checkbox.checked = true;
                        checkbox.onchange = function() {
                            toggleFilterOption(selectId, value);
                        };
                        
                        const label = document.createElement('label');
                        label.className = 'multi-select-option-label';
                        label.htmlFor = `${selectId}_selected_${safeId}`;
                        label.textContent = value;
                        
                        selectedItem.appendChild(checkbox);
                        selectedItem.appendChild(label);
                        selectedContainer.appendChild(selectedItem);
                    });
                } else {
                    // Hide selected section when empty
                    if (selectedHeader) selectedHeader.style.display = 'none';
                    if (divider) divider.style.display = 'none';
                    selectedContainer.style.display = 'none';
                }
            }
            
            // Update checkboxes in all values section
            const options = document.querySelectorAll(`#${selectId}Options .multi-select-option`);
            options.forEach(option => {
                const checkbox = option.querySelector('input[type="checkbox"]');
                const label = option.querySelector('.multi-select-option-label');
                if (!checkbox || !label) return;
                
                const labelText = label.textContent;
                const isSelected = selected.includes(labelText);
                
                checkbox.checked = isSelected;
                option.classList.toggle('selected', isSelected);
            });
            
            // Update country group checkboxes if this is a country filter
            if (selectId === 'filterCountry') {
                updateCountryGroupCheckboxes();
            }
        }
        
        function populateMultiSelectWithGroups(selectId, values) {
            const optionsContainer = document.getElementById(selectId + 'Options');
            if (!optionsContainer) {
                console.error('Options container not found:', selectId + 'Options');
                return;
            }
            
            optionsContainer.innerHTML = '';
            
            if (selectId === 'filterCountry') {
                // Add country groups first
                const groupOrder = ['Brazil', 'EU_UK_JP', 'IMEA', 'India', 'Latam', 'Tier 1', 'WorldWide'];
                
                groupOrder.forEach(groupName => {
                    const option = document.createElement('div');
                    option.className = 'multi-select-option group-option';
                    const safeId = groupName.replace(/[^a-zA-Z0-9]/g, '_');
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `${selectId}_group_${safeId}`;
                    checkbox.onchange = function() {
                        toggleCountryGroup(groupName);
                    };
                    
                    const label = document.createElement('label');
                    label.className = 'multi-select-option-label';
                    label.htmlFor = `${selectId}_group_${safeId}`;
                    label.textContent = groupName;
                    label.style.fontWeight = '600';
                    label.style.color = '#6c5ce7';
                    
                    option.appendChild(checkbox);
                    option.appendChild(label);
                    optionsContainer.appendChild(option);
                });
                
                // Add divider
                const divider = document.createElement('div');
                divider.className = 'multi-select-divider';
                divider.style.margin = '10px 0';
                optionsContainer.appendChild(divider);
            }
            
            // Add individual values
            if (!values || values.length === 0) {
                console.warn('No values to populate for:', selectId);
                return;
            }
            
            values.forEach(value => {
                if (!value || value.trim() === '' || value === 'none') return;
                
                const option = document.createElement('div');
                option.className = 'multi-select-option';
                const safeId = value.replace(/[^a-zA-Z0-9]/g, '_').replace(/'/g, '');
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `${selectId}_${safeId}`;
                checkbox.onchange = function() {
                    toggleFilterOption(selectId, value);
                };
                
                const label = document.createElement('label');
                label.className = 'multi-select-option-label';
                label.htmlFor = `${selectId}_${safeId}`;
                label.textContent = value;
                
                option.appendChild(checkbox);
                option.appendChild(label);
                optionsContainer.appendChild(option);
            });
        }
        
        function toggleCountryGroup(groupName) {
            const groupCountries = countryGroups[groupName] || [];
            if (groupCountries.length === 0) return;
            
            // Check if all countries in group are already selected
            const allSelected = groupCountries.every(country => activeFilters.country.includes(country));
            
            if (allSelected) {
                // Deselect all countries in group
                groupCountries.forEach(country => {
                    const index = activeFilters.country.indexOf(country);
                    if (index > -1) {
                        activeFilters.country.splice(index, 1);
                    }
                });
            } else {
                // Select all countries in group (add only if not already selected)
                groupCountries.forEach(country => {
                    if (!activeFilters.country.includes(country)) {
                        activeFilters.country.push(country);
                    }
                });
            }
            
            // Update checkboxes
            updateCountryGroupCheckboxes();
            updateMultiSelectDisplay('filterCountry', 'country');
            applyFilters();
        }
        
        function updateCountryGroupCheckboxes() {
            const groupOrder = ['Brazil', 'EU_UK_JP', 'IMEA', 'India', 'Latam', 'Tier 1', 'WorldWide'];
            
            groupOrder.forEach(groupName => {
                const groupCountries = countryGroups[groupName] || [];
                if (groupCountries.length === 0) return;
                
                const allSelected = groupCountries.every(country => activeFilters.country.includes(country));
                const safeId = groupName.replace(/[^a-zA-Z0-9]/g, '_');
                const checkbox = document.getElementById(`filterCountry_group_${safeId}`);
                
                if (checkbox) {
                    checkbox.checked = allSelected;
                }
            });
        }
        
        function selectAllOptions(selectId) {
            const filterKey = selectId.replace('filter', '').toLowerCase();
            
            // Get only visible (non-filtered) options
            const options = document.querySelectorAll(`#${selectId}Options .multi-select-option`);
            const visibleValues = [];
            
            options.forEach(option => {
                // Only include options that are currently visible (not hidden by search)
                if (option.style.display !== 'none') {
                    const label = option.querySelector('.multi-select-option-label');
                    if (label) {
                        const value = label.textContent;
                        if (value && !activeFilters[filterKey].includes(value)) {
                            visibleValues.push(value);
                        }
                    }
                }
            });
            
            // Add visible values to selected (avoid duplicates)
            visibleValues.forEach(value => {
                if (!activeFilters[filterKey].includes(value)) {
                    activeFilters[filterKey].push(value);
                }
            });
            
            updateMultiSelectDisplay(selectId, filterKey);
            applyFilters();
        }
        
        function clearAllOptions(selectId) {
            const filterKey = selectId.replace('filter', '').toLowerCase();
            
            activeFilters[filterKey] = [];
            updateMultiSelectDisplay(selectId, filterKey);
            applyFilters();
        }
        
        function applyFilters() {
            try {
                console.log('üîç [FILTERS] Applying filters:', activeFilters);
                
                // Calculate filtered user IDs
                calculateFilteredUsers();
                
                console.log('üîç [FILTERS] Filtered user IDs count:', filteredUserIds ? filteredUserIds.size : 'null');
                
                // Check if date filter is active and resulted in no data
                if (dateFilter.type && filteredUserIds && filteredUserIds.size === 0) {
                    showNotification('No users found matching the date filter', 'error');
                }
                
                // Recalculate and update data
                console.log('üîç [FILTERS] Recalculating filtered data...');
                recalculateFilteredData();
                
                console.log('üîç [FILTERS] Languages analysis after recalculation:', 
                    currentData.languages_analysis ? Object.keys(currentData.languages_analysis).length + ' categories' : 'null');
                
                // Always update the view after filtering to ensure UI is refreshed
                console.log('üîç [FILTERS] Updating view, current view:', currentView);
                updateView();
            } catch (error) {
                console.error('Error applying filters:', error);
                console.error('Error stack:', error.stack);
                console.error('Filtered user IDs:', filteredUserIds ? filteredUserIds.size : 'null');
                console.error('Active filters:', activeFilters);
                showNotification(`Error applying filters: ${error.message}. Please check console for details.`, 'error');
                // Don't restore original data - keep current state so user can see what happened
            }
            
            // Update filtered users list if user records view is active
            if (currentView === 'userrecords') {
                buildFilteredUsersList();
                // Automatically show first user if list is not empty
                if (filteredUsersList && filteredUsersList.length > 0) {
                    currentUserIndex = 0;
                    const firstUserId = filteredUsersList[0];
                    document.getElementById('userIdSearch').value = firstUserId;
                    displayUserDetails(firstUserId);
                } else {
                    currentUserIndex = -1;
                    updateUserNavigation();
                    document.getElementById('userDetails').innerHTML = `
                        <div class="empty-user-state">No users match the current filters.</div>
                    `;
                }
            }
            
            // Save state after filtering
            saveState();
        }
        
        function calculateFilteredUsers() {
            if (!extensionData) {
                filteredUserIds = null;
                return;
            }
            
            // Helper to check if all options are selected
            function allOptionsSelected(selected, available) {
                if (!selected || selected.length === 0) return false;
                if (!available || available.length === 0) return true;
                if (selected.length !== available.length) return false;
                // Sort both arrays and compare
                const sortedSelected = [...selected].sort();
                const sortedAvailable = [...available].sort();
                return sortedSelected.every((val, idx) => val === sortedAvailable[idx]);
            }
            
            // Check if all available options are selected (equivalent to no filter)
            const allCountriesSelected = allOptionsSelected(activeFilters.country, multiSelectData.filterCountry);
            const allDevicesSelected = allOptionsSelected(activeFilters.device, multiSelectData.filterDevice);
            const allFeaturesSelected = allOptionsSelected(activeFilters.feature, multiSelectData.filterFeature);
            
            // If all options are selected for all active filters, treat as no filter
            const countryFilterActive = activeFilters.country.length > 0 && !allCountriesSelected;
            const deviceFilterActive = activeFilters.device.length > 0 && !allDevicesSelected;
            const featureFilterActive = activeFilters.feature.length > 0 && !allFeaturesSelected;
            const dateFilterActive = dateFilter.type !== null;
            
            const hasActiveFilters = countryFilterActive || deviceFilterActive || featureFilterActive || dateFilterActive;
            
            if (!hasActiveFilters) {
                filteredUserIds = null;
                return;
            }
            
            filteredUserIds = new Set();
            
            for (const [userId, extData] of Object.entries(extensionData)) {
                let matches = true;
                
                // Check country (array) - handle 'none' values
                if (countryFilterActive) {
                    const countryValue = extData.country || 'none';
                    if (!activeFilters.country.includes(countryValue)) {
                        matches = false;
                    }
                }
                
                // Check device (array) - only if device exists in data
                if (deviceFilterActive && extData.device !== undefined) {
                    const deviceValue = extData.device || 'none';
                    if (!activeFilters.device.includes(deviceValue)) {
                        matches = false;
                    }
                }
                
                // Check feature (array) - only if feature exists in data
                if (featureFilterActive && extData.feature !== undefined) {
                    const featureValue = extData.feature || 'none';
                    if (!activeFilters.feature.includes(featureValue)) {
                        matches = false;
                    }
                }
                
                // Check date filter
                if (matches && dateFilter.type) {
                    // If date filter is active, user must have a trial date
                    if (!extData.trialDate) {
                        matches = false;
                    } else {
                        // extData.trialDate is already a Date object from loadFromMergedFile
                        let trialDate = extData.trialDate;
                        
                        // If it's not a Date object, try to parse it
                        if (!(trialDate instanceof Date)) {
                            trialDate = new Date(trialDate);
                        }
                        
                        if (isNaN(trialDate.getTime())) {
                            matches = false;
                        } else {
                            // Normalize to start of day for comparison
                            trialDate = new Date(trialDate);
                            trialDate.setHours(0, 0, 0, 0);
                            
                            const now = new Date();
                            now.setHours(0, 0, 0, 0);
                            
                            if (dateFilter.type === 'last') {
                                const days = dateFilter.value;
                                if (typeof days !== 'number' || isNaN(days) || days < 0) {
                                    matches = false;
                                } else {
                                    const thresholdDate = new Date(now);
                                    thresholdDate.setDate(thresholdDate.getDate() - days);
                                    thresholdDate.setHours(0, 0, 0, 0);
                                    if (trialDate < thresholdDate) {
                                        matches = false;
                                    }
                                }
                            } else if (dateFilter.type === 'since') {
                                // dateFilter.value is a string in format 'YYYY-MM-DD' from date input
                                let sinceDate;
                                if (typeof dateFilter.value === 'string') {
                                    // Parse date string (format: 'YYYY-MM-DD')
                                    sinceDate = new Date(dateFilter.value + 'T00:00:00');
                                } else {
                                    sinceDate = new Date(dateFilter.value);
                                }
                                
                                if (isNaN(sinceDate.getTime())) {
                                    matches = false;
                                } else {
                                    sinceDate.setHours(0, 0, 0, 0);
                                    if (trialDate < sinceDate) {
                                        matches = false;
                                    }
                                }
                            } else if (dateFilter.type === 'between') {
                                const fromDate = new Date(dateFilter.value.from);
                                const toDate = new Date(dateFilter.value.to);
                                if (isNaN(fromDate.getTime()) || isNaN(toDate.getTime())) {
                                    matches = false;
                                } else {
                                    fromDate.setHours(0, 0, 0, 0);
                                    toDate.setHours(23, 59, 59, 999);
                                    if (trialDate < fromDate || trialDate > toDate) {
                                        matches = false;
                                    }
                                }
                            }
                        }
                    }
                }
                
                if (matches) {
                    filteredUserIds.add(userId);
                }
            }
            
            // Debug: Log filtering results
            if (dateFilterActive) {
                console.log(`Date filter results: ${filteredUserIds.size} users matched out of ${Object.keys(extensionData).length} total users`);
                if (filteredUserIds.size === 0) {
                    // Get sample dates to debug
                    const sampleDates = [];
                    let sampleCount = 0;
                    for (const [uid, data] of Object.entries(extensionData)) {
                        if (sampleCount >= 5) break;
                        if (data.trialDate) {
                            sampleDates.push({
                                userId: uid.substring(0, 8),
                                trialDate: data.trialDate instanceof Date ? data.trialDate.toISOString() : String(data.trialDate)
                            });
                            sampleCount++;
                        }
                    }
                    
                    let parsedDateStr = null;
                    if (dateFilter.type === 'since') {
                        const testDate = typeof dateFilter.value === 'string' && !dateFilter.value.includes('T') 
                            ? new Date(dateFilter.value + 'T00:00:00')
                            : new Date(dateFilter.value);
                        parsedDateStr = !isNaN(testDate.getTime()) ? testDate.toISOString() : 'invalid';
                    }
                    
                    console.log('Date filter details:', {
                        type: dateFilter.type,
                        value: dateFilter.value,
                        valueType: typeof dateFilter.value,
                        parsedDate: parsedDateStr,
                        now: new Date().toISOString(),
                        sampleDates: sampleDates
                    });
                }
            }
        }
        
        function recalculateFilteredData() {
            // If no filters are active, use original data
            if (!filteredUserIds) {
                // Always restore original data when no filters are active
                if (originalData) {
                    currentData = originalData;
                } else if (!currentData || (currentData && currentData.total_records === 0)) {
                    // If originalData doesn't exist but currentData is empty, we can't recover
                    // This shouldn't happen, but handle it gracefully
                    return;
                }
                // Don't call updateView() here - let the caller do it
                return;
            }
            
            // If date filter is active but no users matched, show empty state but still update view
            if (dateFilter.type && filteredUserIds instanceof Set && filteredUserIds.size === 0) {
                // Don't clear the entire panel structure - just clear empty state if it exists
                // This preserves the panel structure (level1ChartView, etc.) for future use
                const activePanel = document.querySelector('.view-panel.active');
                if (activePanel) {
                    const emptyState = activePanel.querySelector('.empty-state');
                    if (emptyState) {
                        // Only remove empty state, keep panel structure
                        emptyState.remove();
                    }
                    // Clear any chart content but keep the structure
                    const level1ChartView = activePanel.querySelector('#level1ChartView');
                    if (level1ChartView) {
                        // Clear only the content, not the entire element
                        const chartContainer = level1ChartView.querySelector('.chart-container');
                        const categoryList = level1ChartView.querySelector('.category-list');
                        if (chartContainer) chartContainer.innerHTML = '';
                        if (categoryList) categoryList.innerHTML = '';
                    }
                }
                
                // Create empty filtered data structure
                currentData = {
                    ...(originalData || currentData),
                    total_records: 0,
                    level1_distribution: {},
                    level2_by_level1: {},
                    handwritten_analysis: {},
                    image_types_analysis: {},
                    scan_photo_analysis: {},
                    languages_analysis: {},
                    personal_data_analysis: {}
                };
                showEmptyState('No users found matching the date filter. Please ensure the merged CSV file contains subscription_started_at dates.');
                // Don't call updateView() here as it will try to render with empty data and may cause errors
                return;
            }
            
            if (!userMappings) {
                console.warn('No user mappings available');
                updateView();
                return;
            }
            
            // Recalculate statistics based on filtered users
            const filteredData = {
                level1_distribution: {},
                level2_by_level1: {},
                handwritten_analysis: {},
                image_types_analysis: {},
                scan_photo_analysis: {},
                languages_analysis: {},
                personal_data_analysis: {}
            };
            
            // Count by category for filtered users
            const level1Counts = {};
            const level2Counts = {};
            const handwrittenCounts = {};
            const scanPhotoCounts = {};
            const personalDataCounts = {};
            const imageTypesCounts = {};
            const imageTypesDocs = {}; // Track unique documents with images per category
            const languageCounts = {};
            
            let totalFiltered = 0;
            
            if (!filteredUserIds || filteredUserIds.size === 0) {
                console.warn('üîç [RECALCULATE] No filtered user IDs available');
                currentData = {
                    ...(originalData || currentData),
                    total_records: 0,
                    level1_distribution: {},
                    level2_by_level1: {},
                    handwritten_analysis: {},
                    image_types_analysis: {},
                    scan_photo_analysis: {},
                    languages_analysis: {},
                    personal_data_analysis: {}
                };
                return;
            }
            
            console.log('üîç [RECALCULATE] Processing', filteredUserIds.size, 'filtered users');
            
            for (const userId of filteredUserIds) {
                const mappings = userMappings[userId];
                if (!mappings) continue;
                
                // Handle both old format (single object) and new format (array)
                const records = Array.isArray(mappings) ? mappings : [mappings];
                
                for (const mapping of records) {
                    totalFiltered++;
                    
                    const level1 = mapping.cluster_level1;
                    const level2 = mapping.cluster_level2;
                    
                    // Level 1 counts
                    level1Counts[level1] = (level1Counts[level1] || 0) + 1;
                    
                    // Level 2 counts
                    if (!level2Counts[level1]) level2Counts[level1] = {};
                    level2Counts[level1][level2] = (level2Counts[level1][level2] || 0) + 1;
                    
                    // Handwritten
                    if (!handwrittenCounts[level1]) handwrittenCounts[level1] = { total: 0, with: 0 };
                    handwrittenCounts[level1].total++;
                    if (mapping.contains_handwritten_text) handwrittenCounts[level1].with++;
                    
                    // Scan/Photo
                    if (!scanPhotoCounts[level1]) scanPhotoCounts[level1] = { total: 0, with: 0 };
                    scanPhotoCounts[level1].total++;
                    if (mapping.is_scan_or_photo) scanPhotoCounts[level1].with++;
                    
                    // Personal Data
                    if (!personalDataCounts[level1]) personalDataCounts[level1] = { total: 0, with: 0 };
                    personalDataCounts[level1].total++;
                    if (mapping.contains_personal_data) personalDataCounts[level1].with++;
                    
                    // Image types - count each type, but also track unique documents with images
                    if (!imageTypesCounts[level1]) imageTypesCounts[level1] = {};
                    if (!imageTypesDocs[level1]) imageTypesDocs[level1] = new Set();
                    
                    if (mapping.image_types && Array.isArray(mapping.image_types) && mapping.image_types.length > 0) {
                        // This document has at least one image type
                        imageTypesDocs[level1].add(`${userId}_${records.indexOf(mapping)}`);
                        
                        // Count each image type
                        mapping.image_types.forEach(type => {
                            if (!imageTypesCounts[level1][type]) imageTypesCounts[level1][type] = 0;
                            imageTypesCounts[level1][type]++;
                        });
                    }
                    
                    // Languages
                    if (!languageCounts[level1]) languageCounts[level1] = {};
                    if (mapping.document_languages) {
                        try {
                            let langList = [];
                            if (typeof mapping.document_languages === 'string') {
                                const langStr = mapping.document_languages.trim();
                                if (langStr.startsWith('[') && langStr.endsWith(']')) {
                                    // Try to parse as JSON, but handle single quotes
                                    try {
                                        langList = JSON.parse(langStr);
                                    } catch (jsonError) {
                                        // If JSON.parse fails (e.g., single quotes), try to extract values manually
                                        // Remove brackets and split by comma, handling both single and double quotes
                                        const inner = langStr.slice(1, -1).trim();
                                        if (inner) {
                                            langList = inner.split(',').map(l => {
                                                // Remove quotes (both single and double) and whitespace
                                                return l.trim().replace(/^['"]|['"]$/g, '');
                                            }).filter(l => l.length > 0);
                                        }
                                    }
                                } else {
                                    // Not an array format, split by comma
                                    langList = langStr.split(',').map(l => l.trim().replace(/['"]/g, '')).filter(l => l.length > 0);
                                }
                            } else if (Array.isArray(mapping.document_languages)) {
                                langList = mapping.document_languages;
                            }
                            
                            if (langList.length > 0) {
                                langList.forEach(lang => {
                                    if (lang && typeof lang === 'string' && lang.trim()) {
                                        const langKey = lang.trim();
                                        if (langKey.length > 0) {
                                            if (!languageCounts[level1][langKey]) {
                                                languageCounts[level1][langKey] = { count: 0 };
                                            }
                                            languageCounts[level1][langKey].count++;
                                        }
                                    }
                                });
                            }
                        } catch (e) {
                            console.warn('üîç [LANGUAGES] Error parsing document_languages for user:', mapping.user_id, 'value:', mapping.document_languages, 'error:', e.message);
                        }
                    }
                }
            }
            
            // Build filtered data structure
            for (const [level1, count] of Object.entries(level1Counts)) {
                filteredData.level1_distribution[level1] = {
                    count: count,
                    percentage: round((count / totalFiltered) * 100, 2)
                };
                
                // Level 2
                if (level2Counts[level1]) {
                    filteredData.level2_by_level1[level1] = {};
                    for (const [level2, l2count] of Object.entries(level2Counts[level1])) {
                        filteredData.level2_by_level1[level1][level2] = {
                            count: l2count,
                            percentage: round((l2count / count) * 100, 2)
                        };
                    }
                }
                
                // Handwritten
                if (handwrittenCounts[level1]) {
                    const hw = handwrittenCounts[level1];
                    filteredData.handwritten_analysis[level1] = {
                        total: hw.total,
                        with_handwritten: hw.with,
                        percentage: round((hw.with / hw.total) * 100, 2)
                    };
                }
                
                // Scan/Photo
                if (scanPhotoCounts[level1]) {
                    const sp = scanPhotoCounts[level1];
                    filteredData.scan_photo_analysis[level1] = {
                        total: sp.total,
                        scans_or_photos: sp.with,
                        percentage: round((sp.with / sp.total) * 100, 2)
                    };
                }
                
                // Personal Data
                if (personalDataCounts[level1]) {
                    const pd = personalDataCounts[level1];
                    filteredData.personal_data_analysis[level1] = {
                        total: pd.total,
                        with_personal_data: pd.with,
                        percentage: round((pd.with / pd.total) * 100, 2)
                    };
                }
                
                // Image Types
                if (imageTypesCounts[level1]) {
                    filteredData.image_types_analysis[level1] = {};
                    const catTotal = count;
                    const docsWithImages = imageTypesDocs[level1] ? imageTypesDocs[level1].size : 0;
                    
                    for (const [type, typeCount] of Object.entries(imageTypesCounts[level1])) {
                        filteredData.image_types_analysis[level1][type] = {
                            documents_with_type: typeCount,
                            percentage_of_docs: round((typeCount / catTotal) * 100, 2)
                        };
                    }
                    
                    // Store the count of unique documents with images for percentage calculation
                    filteredData.image_types_analysis[level1]._docsWithImages = docsWithImages;
                    filteredData.image_types_analysis[level1]._totalDocs = catTotal;
                }
                
                // Languages
                if (languageCounts[level1] && Object.keys(languageCounts[level1]).length > 0) {
                    filteredData.languages_analysis[level1] = {};
                    const catTotal = count;
                    for (const [lang, langInfo] of Object.entries(languageCounts[level1])) {
                        if (langInfo && langInfo.count > 0) {
                            filteredData.languages_analysis[level1][lang] = {
                                count: langInfo.count,
                                percentage: round((langInfo.count / catTotal) * 100, 2)
                            };
                        }
                    }
                    // Only keep the entry if it has languages
                    if (Object.keys(filteredData.languages_analysis[level1]).length === 0) {
                        delete filteredData.languages_analysis[level1];
                    } else {
                        console.log(`üîç [LANGUAGES] Category "${level1}": ${Object.keys(filteredData.languages_analysis[level1]).length} languages, total docs: ${catTotal}`);
                    }
                }
            }
            
            // Create temporary filtered data object
            // Use global originalData if available, otherwise use currentData
            const baseData = originalData || currentData;
            currentData = {
                ...baseData,
                total_records: totalFiltered,
                level1_distribution: filteredData.level1_distribution,
                level2_by_level1: filteredData.level2_by_level1,
                handwritten_analysis: filteredData.handwritten_analysis,
                image_types_analysis: filteredData.image_types_analysis,
                scan_photo_analysis: filteredData.scan_photo_analysis,
                languages_analysis: filteredData.languages_analysis,
                personal_data_analysis: filteredData.personal_data_analysis
            };
            
            console.log('üîç [RECALCULATE] Languages analysis categories:', Object.keys(filteredData.languages_analysis).length);
            console.log('üîç [RECALCULATE] Sample language data:', 
                Object.keys(filteredData.languages_analysis).slice(0, 3).map(cat => ({
                    category: cat,
                    languages: Object.keys(filteredData.languages_analysis[cat]).length
                })));
            
            updateUI();
            
            // Update the view with filtered data
            updateView();
            
            // Restore original data reference (but keep filtered calculations)
            // currentData will be updated on next load
        }
        
        async function clearFilters() {
            activeFilters = { country: [], device: [], feature: [] };
            dateFilter = { type: null, value: null };
            filteredUserIds = null;
            
            // Restore original data if it exists
            if (originalData) {
                currentData = originalData;
            }
            
            // Reset all checkboxes
            document.querySelectorAll('.multi-select-option input[type="checkbox"]').forEach(cb => {
                cb.checked = false;
            });
            document.querySelectorAll('.multi-select-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            
            // Reset displays
            updateMultiSelectDisplay('filterCountry', 'country');
            updateMultiSelectDisplay('filterDevice', 'device');
            updateMultiSelectDisplay('filterFeature', 'feature');
            updateDateFilterDisplay();
            
            // Close all dropdowns
            document.querySelectorAll('.multi-select').forEach(ms => {
                ms.classList.remove('active');
            });
            document.querySelectorAll('.date-filter-wrapper').forEach(df => {
                df.classList.remove('active');
            });
            
            // Restore original data directly (more efficient than reloading)
            if (originalData) {
                currentData = originalData;
            }
            
            // Recalculate and update view to restore data
            recalculateFilteredData();
            updateView();
            
            // Update filtered users list if user records view is active
            if (currentView === 'userrecords') {
                buildFilteredUsersList();
                if (filteredUsersList && filteredUsersList.length > 0) {
                    currentUserIndex = 0;
                    displayUserDetails(filteredUsersList[0]);
                }
            }
            
            // Reload original data
            showLoader('Reloading data...', 'Clearing filters...');
            try {
                await loadProductData(currentProduct);
            } finally {
                hideLoader();
            }
        }
        
        // Close multi-selects and date filter when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.multi-select') && !e.target.closest('.date-filter-wrapper')) {
                document.querySelectorAll('.multi-select').forEach(ms => {
                    ms.classList.remove('active');
                });
                document.querySelectorAll('.date-filter-wrapper').forEach(df => {
                    df.classList.remove('active');
                });
            }
        });
        
        // Date filter functions
        function toggleDateFilter() {
            const wrapper = document.querySelector('.date-filter-wrapper');
            if (!wrapper) return;
            
            const isActive = wrapper.classList.contains('active');
            
            // Close all other dropdowns
            document.querySelectorAll('.multi-select').forEach(ms => {
                ms.classList.remove('active');
            });
            
            // Toggle date filter
            if (!isActive) {
                wrapper.classList.add('active');
            } else {
                wrapper.classList.remove('active');
            }
        }
        
        function setDateFilterMode(mode) {
            // Clear previous date filter ONLY when switching between different modes (last/since/between)
            // Don't clear when staying in the same mode (e.g., switching from "last" to "last")
            const previousMode = dateFilter.type;
            if (previousMode && previousMode !== mode) {
                // Reset date filter to clear previous state
                dateFilter = { type: null, value: null };
                filteredUserIds = null;
                
                // Restore original data
                if (originalData) {
                    currentData = originalData;
                }
                
                // Update view to show restored data
                recalculateFilteredData();
                updateView();
            }
            // If previousMode === mode, do nothing - just update UI
            
            // Update mode buttons
            document.querySelectorAll('.date-mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            const modeBtn = document.querySelector(`[data-mode="${mode}"]`);
            if (modeBtn) modeBtn.classList.add('active');
            
            // Update content visibility
            document.querySelectorAll('.date-mode-content').forEach(content => {
                content.classList.remove('active');
            });
            const modeContent = document.getElementById(`dateMode${mode.charAt(0).toUpperCase() + mode.slice(1)}Content`);
            if (modeContent) modeContent.classList.add('active');
            
            // Update date filter display
            updateDateFilterDisplay();
        }
        
        function selectDatePreset(days) {
            try {
                if (typeof days !== 'number' || isNaN(days) || days < 0) {
                    showNotification('Invalid number of days', 'error');
                    return;
                }
                
                // Restore original data before applying new filter (in case previous filter left empty state)
                if (originalData && (!currentData || currentData.total_records === 0)) {
                    currentData = originalData;
                }
                
                // Clear previous empty state but preserve panel structure
                const activePanel = document.querySelector('.view-panel.active');
                if (activePanel) {
                    // Remove empty state if it exists, but keep panel structure
                    const emptyState = activePanel.querySelector('.empty-state');
                    if (emptyState) {
                        emptyState.remove();
                    }
                    
                    // Ensure level1ChartView exists and is ready
                    let level1ChartView = activePanel.querySelector('#level1ChartView');
                    if (!level1ChartView && activePanel.id === 'level1') {
                        // Recreate if missing
                        level1ChartView = document.createElement('div');
                        level1ChartView.id = 'level1ChartView';
                        const levelSelector = activePanel.querySelector('.level-selector');
                        if (levelSelector && levelSelector.nextSibling) {
                            activePanel.insertBefore(level1ChartView, levelSelector.nextSibling);
                        } else {
                            activePanel.appendChild(level1ChartView);
                        }
                    }
                }
                
                dateFilter = {
                    type: 'last',
                    value: days
                };
                updateDateFilterDisplay();
                applyFilters();
                toggleDateFilter();
            } catch (error) {
                console.error('Error selecting date preset:', error);
                showNotification('Error applying date filter. Please try again.', 'error');
                // Restore original data on error
                if (originalData) {
                    currentData = originalData;
                    filteredUserIds = null;
                    dateFilter = { type: null, value: null };
                    updateView();
                }
            }
        }
        
        function applySinceDate() {
            const sinceDate = document.getElementById('sinceDateInput').value;
            if (!sinceDate) {
                showNotification('Please select a date', 'error');
                return;
            }
            
            dateFilter = {
                type: 'since',
                value: sinceDate
            };
            updateDateFilterDisplay();
            applyFilters();
            toggleDateFilter();
        }
        
        function applyBetweenDates() {
            const fromDate = document.getElementById('fromDateInput').value;
            const toDate = document.getElementById('toDateInput').value;
            
            if (!fromDate || !toDate) {
                showNotification('Please select both dates', 'error');
                return;
            }
            
            if (new Date(fromDate) > new Date(toDate)) {
                showNotification('From date must be before To date', 'error');
                return;
            }
            
            dateFilter = {
                type: 'between',
                value: { from: fromDate, to: toDate }
            };
            updateDateFilterDisplay();
            applyFilters();
            toggleDateFilter();
        }
        
        function cancelDateFilter() {
            toggleDateFilter();
        }
        
        function updateDateFilterDisplay() {
            const displayText = document.getElementById('dateFilterText');
            if (!displayText) return;
            
            if (!dateFilter.type) {
                displayText.textContent = 'All Dates';
                return;
            }
            
            if (dateFilter.type === 'last') {
                displayText.textContent = `Last ${dateFilter.value} days`;
            } else if (dateFilter.type === 'since') {
                const date = new Date(dateFilter.value);
                displayText.textContent = `Since ${date.toLocaleDateString()}`;
            } else if (dateFilter.type === 'between') {
                const from = new Date(dateFilter.value.from);
                const to = new Date(dateFilter.value.to);
                displayText.textContent = `${from.toLocaleDateString()} - ${to.toLocaleDateString()}`;
            }
        }
        
        function round(num, decimals) {
            return Math.round(num * Math.pow(10, decimals)) / Math.pow(10, decimals);
        }

        // Product selector
        document.querySelectorAll('.product-btn').forEach(btn => {
            btn.addEventListener('click', async () => {
                document.querySelectorAll('.product-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentProduct = btn.dataset.product;
                saveState();
                
                // Show loader
                showLoader(`Loading ${btn.textContent}...`);
                
                try {
                    await loadProductData(currentProduct);
                } finally {
                    // Hide loader when done (even if there was an error)
                    hideLoader();
                }
            });
        });

        // View selector
        document.querySelectorAll('.view-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.view-panel').forEach(p => p.classList.remove('active'));
                btn.classList.add('active');
                const view = btn.dataset.view;
                document.getElementById(view).classList.add('active');
                currentView = view;
                saveState();
                updateView();
            });
        });

        function updateUI() {
            if (!currentData) return;

            // Update stats overlay elements if they exist
            const totalRecordsEl = document.getElementById('totalRecords');
            const level1CountEl = document.getElementById('level1Count');
            if (totalRecordsEl) {
                totalRecordsEl.textContent = currentData.total_records.toLocaleString();
            }
            if (level1CountEl) {
                level1CountEl.textContent = Object.keys(currentData.level1_distribution).length;
            }

            // Update level 1 selector for level 2 view - sorted by popularity with % and count
            const level1Selector = document.getElementById('level1Selector');
            if (level1Selector) {
                level1Selector.innerHTML = '<option value="">Select Level 1 Category...</option>';
            }
            
            // Sort categories by count (most popular first)
            const categories = Object.entries(currentData.level1_distribution)
                .sort((a, b) => b[1].count - a[1].count);
            
            categories.forEach(([cat, info]) => {
                const option = document.createElement('option');
                option.value = cat;
                const fullText = `${cat} - ${info.count.toLocaleString()} docs (${info.percentage.toFixed(2)}%)`;
                option.textContent = fullText;
                option.setAttribute('data-full-text', fullText);
                if (level1Selector) level1Selector.appendChild(option);
            });
            
            // Add event listener to update display text when dropdown is opened/closed
            if (level1Selector) {
                level1Selector.addEventListener('focus', function() {
                    // When dropdown opens, show full text in options
                    Array.from(this.options).forEach(opt => {
                        if (opt.value && opt.getAttribute('data-full-text')) {
                            opt.textContent = opt.getAttribute('data-full-text');
                        }
                    });
                });
                
                // Remove any existing change listeners by replacing the element
                const oldOnChange = level1Selector.onchange;
                level1Selector.onchange = null;
                
                level1Selector.addEventListener('change', function() {
                    // When selection changes, update display to show just category name
                    const selected = this.options[this.selectedIndex];
                    if (selected && selected.value) {
                        const categoryName = selected.getAttribute('data-full-text')?.split(' - ')[0] || selected.textContent.split(' - ')[0];
                        selected.textContent = categoryName;
                        // Restore full text to other options
                        Array.from(this.options).forEach(opt => {
                            if (opt !== selected && opt.value && opt.getAttribute('data-full-text')) {
                                opt.textContent = opt.getAttribute('data-full-text');
                            }
                        });
                    }
                    // Call renderLevel2View to update the chart and data
                    renderLevel2View();
                });
            }

            // Update image types category selector with stats
            const imgTypesSelector = document.getElementById('imagetypesCategorySelector');
            if (imgTypesSelector) {
                const categories = Object.entries(currentData.level1_distribution)
                    .sort((a, b) => b[1].count - a[1].count);
                
                // Calculate thresholds for core vs non-core
                const totalDocs = currentData.total_records;
                const coreThreshold = totalDocs * 0.05; // 5% of total = core category
                const midThreshold = totalDocs * 0.01; // 1% of total = mid category
                
                imgTypesSelector.innerHTML = '<option value="">Select Category...</option>';
                categories.forEach(([cat, info]) => {
                    const option = document.createElement('option');
                    option.value = cat;
                    
                    // Format option text with stats
                    const countStr = info.count.toLocaleString();
                    const pctStr = info.percentage.toFixed(2);
                    
                    option.textContent = `${cat} - ${countStr} docs (${pctStr}%)`;
                    if (info.count >= coreThreshold) {
                        option.className = 'category-option-core';
                    }
                    imgTypesSelector.appendChild(option);
                });
                
                // Add event listener
                imgTypesSelector.removeEventListener('change', renderImageTypesView);
                imgTypesSelector.addEventListener('change', renderImageTypesView);
            }

            updateView();
        }

        function updateView() {
            // Always check if we need to restore panel structure
            const activePanel = document.querySelector('.view-panel.active');
            if (activePanel) {
                const emptyState = activePanel.querySelector('.empty-state');
                // If empty state exists and we have data, clear it to restore structure
                // BUT: Don't clear languages panel as it has a selector that needs to be preserved
                if (emptyState && currentData && currentData.total_records > 0 && activePanel.id !== 'languages') {
                    activePanel.innerHTML = '';
                }
                // If panel is empty but we have data, we need to restore the structure
                // This will be handled by the render functions
            }
            
            if (!currentData) return;

            switch (currentView) {
                case 'level1':
                    renderLevel1View();
                    break;
                case 'level2':
                    renderLevel2View();
                    break;
                case 'handwritten':
                    renderHandwrittenView();
                    break;
                case 'imagetypes':
                    renderImageTypesView();
                    break;
                case 'scanphoto':
                    renderScanPhotoView();
                    break;
                case 'languages':
                    // Ensure panel is active before rendering
                    const languagesPanel = document.getElementById('languages');
                    if (languagesPanel) {
                        languagesPanel.classList.add('active');
                        // Use setTimeout to ensure DOM is ready
                        setTimeout(() => {
                            renderLanguagesView();
                        }, 0);
                    } else {
                        console.error('üîç [UPDATE VIEW] Languages panel not found');
                    }
                    break;
                case 'personaldata':
                    renderPersonalDataView();
                    break;
                case 'userrecords':
                    renderUserRecordsView();
                    break;
            }
        }
        
        function renderUserRecordsView() {
            // Build filtered users list when view is opened
            buildFilteredUsersList();
            
            // Show first record by default
            if (filteredUsersList && filteredUsersList.length > 0) {
                currentUserIndex = 0;
                const firstUserId = filteredUsersList[0];
                document.getElementById('userIdSearch').value = firstUserId;
                displayUserDetails(firstUserId);
            } else {
                currentUserIndex = -1;
                document.getElementById('userDetails').innerHTML = `
                    <div class="empty-user-state">No users available. Please check your filters.</div>
                `;
            }
            
            updateUserNavigation();
        }
        
        function buildFilteredUsersList() {
            if (!userMappings) {
                filteredUsersList = null;
                return;
            }
            
            // If filters are active, use filteredUserIds, otherwise use all users
            if (filteredUserIds && filteredUserIds.size > 0) {
                filteredUsersList = Array.from(filteredUserIds);
            } else {
                // Use all users from mappings
                filteredUsersList = Object.keys(userMappings);
            }
            
            // Sort for consistent navigation
            filteredUsersList.sort();
            
        }
        
        function searchUserById() {
            const searchInput = document.getElementById('userIdSearch');
            const userId = searchInput.value.trim();
            
            if (!userId) {
                showNotification('Please enter a User ID');
                return;
            }
            
            if (!userMappings || !userMappings[userId]) {
                document.getElementById('userDetails').innerHTML = `
                    <div class="empty-user-state">User ID "${userId}" not found</div>
                `;
                currentUserIndex = -1;
                updateUserNavigation();
                return;
            }
            
            // Find user in filtered list
            buildFilteredUsersList();
            if (filteredUsersList) {
                currentUserIndex = filteredUsersList.indexOf(userId);
                if (currentUserIndex === -1) {
                    // User exists but not in filtered list
                    document.getElementById('userDetails').innerHTML = `
                        <div class="empty-user-state">User ID "${userId}" found but not in current filter results</div>
                    `;
                    updateUserNavigation();
                    return;
                }
            } else {
                currentUserIndex = -1;
            }
            
            displayUserDetails(userId);
        }
        
        function displayUserDetails(userId) {
            if (!userMappings || !userMappings[userId]) {
                return;
            }
            
            const mapping = userMappings[userId];
            const records = Array.isArray(mapping) ? mapping : [mapping];
            const extData = extensionData && extensionData[userId] ? extensionData[userId] : null;
            
            // Show only first record to fit on one page
            const record = records[0];
            
            let html = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                    <!-- User Information Section (Left) -->
                    <div class="user-info-section">
                        <h4 style="margin: 0 0 16px 0; color: #495057; font-size: 1.1em; font-weight: 600; border-bottom: 2px solid #dee2e6; padding-bottom: 8px;">User Information</h4>
                        <div class="user-detail-rows-container">
                            <div class="user-detail-row">
                                <div class="user-detail-label">User ID</div>
                                <div class="user-detail-value" style="font-size: 14px; color: #6c757d; font-weight: 400;">${escapeHtml(userId)}</div>
                            </div>
                            ${records.length > 1 ? `
                            <div class="user-detail-row">
                                <div class="user-detail-label">Records Count</div>
                                <div class="user-detail-value">${records.length} records (showing first)</div>
                            </div>
                            ` : ''}
                            ${extData && extData.email ? `
                            <div class="user-detail-row">
                                <div class="user-detail-label">Email</div>
                                <div class="user-detail-value">${escapeHtml(extData.email)}</div>
                            </div>
                            ` : ''}
                            ${extData && extData.country && extData.country !== 'none' ? `
                            <div class="user-detail-row">
                                <div class="user-detail-label">Country</div>
                                <div class="user-detail-value"><strong>${escapeHtml(extData.country)}</strong></div>
                            </div>
                            ` : ''}
                            ${extData && extData.device && extData.device !== 'none' ? `
                            <div class="user-detail-row">
                                <div class="user-detail-label">Device</div>
                                <div class="user-detail-value"><strong>${escapeHtml(extData.device)}</strong></div>
                            </div>
                            ` : ''}
                            ${extData && extData.feature && extData.feature !== 'none' ? `
                            <div class="user-detail-row">
                                <div class="user-detail-label">Feature</div>
                                <div class="user-detail-value"><strong>${escapeHtml(extData.feature)}</strong></div>
                            </div>
                            ` : ''}
                        </div>
                    </div>
                    
                    <!-- Document Information Section (Right) -->
                    <div class="document-info-section">
                        <h4 style="margin: 0 0 16px 0; color: #495057; font-size: 1.1em; font-weight: 600; border-bottom: 2px solid #dee2e6; padding-bottom: 8px;">Document Information</h4>
                        <div class="user-detail-rows-container">
                            <div class="user-detail-row">
                                <div class="user-detail-label">Cluster Level 1</div>
                                <div class="user-detail-value">${escapeHtml(record.cluster_level1 || 'N/A')}</div>
                            </div>
                            
                            <div class="user-detail-row">
                                <div class="user-detail-label">Cluster Level 2</div>
                                <div class="user-detail-value">${escapeHtml(record.cluster_level2 || 'N/A')}</div>
                            </div>
                            
                            ${record.cluster_level3 && String(record.cluster_level3).trim() !== '' ? `
                            <div class="user-detail-row">
                                <div class="user-detail-label">Cluster Level 3</div>
                                <div class="user-detail-value">${escapeHtml(String(record.cluster_level3))}</div>
                            </div>
                            ` : ''}
                            
                            <div class="user-detail-row">
                                <div class="user-detail-label">Handwritten Text</div>
                                <div class="user-detail-value">
                                    <span class="user-detail-badge ${record.contains_handwritten_text ? 'badge-true' : 'badge-false'}">
                                        ${record.contains_handwritten_text ? 'Yes' : 'No'}
                                    </span>
                                </div>
                            </div>
                            
                            <div class="user-detail-row">
                                <div class="user-detail-label">Scan/Photo</div>
                                <div class="user-detail-value">
                                    <span class="user-detail-badge ${record.is_scan_or_photo ? 'badge-true' : 'badge-false'}">
                                        ${record.is_scan_or_photo ? 'Yes' : 'No'}
                                    </span>
                                </div>
                            </div>
                            
                            <div class="user-detail-row">
                                <div class="user-detail-label">Personal Data</div>
                                <div class="user-detail-value">
                                    <span class="user-detail-badge ${record.contains_personal_data ? 'badge-true' : 'badge-false'}">
                                        ${record.contains_personal_data ? 'Yes' : 'No'}
                                    </span>
                                </div>
                            </div>
                            
                            <div class="user-detail-row">
                                <div class="user-detail-label">Image Count</div>
                                <div class="user-detail-value">${record.image_count || 0}</div>
                            </div>
                            
                            ${record.image_types && record.image_types.length > 0 ? `
                            <div class="user-detail-row">
                                <div class="user-detail-label">Image Types</div>
                                <div class="user-detail-value">${record.image_types.map(t => escapeHtml(t)).join(', ') || 'None'}</div>
                            </div>
                            ` : ''}
                            
                            ${record.document_languages ? `
                            <div class="user-detail-row">
                                <div class="user-detail-label">Document Languages</div>
                                <div class="user-detail-value">${escapeHtml(record.document_languages)}</div>
                            </div>
                            ` : ''}
                        </div>
                    </div>
                </div>
            `;
            
            document.getElementById('userDetails').innerHTML = html;
            updateUserNavigation();
        }
        
        function previousUser() {
            if (!filteredUsersList || filteredUsersList.length === 0 || currentUserIndex <= 0) {
                return;
            }
            
            currentUserIndex--;
            const userId = filteredUsersList[currentUserIndex];
            document.getElementById('userIdSearch').value = userId;
            displayUserDetails(userId);
        }
        
        function nextUser() {
            if (!filteredUsersList || filteredUsersList.length === 0 || currentUserIndex >= filteredUsersList.length - 1) {
                return;
            }
            
            currentUserIndex++;
            const userId = filteredUsersList[currentUserIndex];
            document.getElementById('userIdSearch').value = userId;
            displayUserDetails(userId);
        }
        
        function updateUserNavigation() {
            const prevBtn = document.getElementById('prevUserBtn');
            const nextBtn = document.getElementById('nextUserBtn');
            const counter = document.getElementById('userCounter');
            
            if (!filteredUsersList || filteredUsersList.length === 0) {
                prevBtn.disabled = true;
                nextBtn.disabled = true;
                counter.textContent = '- / -';
                return;
            }
            
            prevBtn.disabled = currentUserIndex <= 0;
            nextBtn.disabled = currentUserIndex >= filteredUsersList.length - 1;
            counter.textContent = `${currentUserIndex >= 0 ? currentUserIndex + 1 : '-'} / ${filteredUsersList.length}`;
        }
        
        // Load extension data and user mappings for all products for global search
        async function loadAllProductsExtensionData() {
            const products = ['pdfguru', 'pdfleader', 'thebestpdf'];
            for (const product of products) {
                try {
                    // Load user mappings for this product
                    const mappingFile = `${product}_user_mappings.json`;
                    const mappingResponse = await fetch(mappingFile);
                    if (mappingResponse.ok) {
                        allProductsUserMappings[product] = await mappingResponse.json();
                    }
                    
                    // Try merged file first
                    let mergedFile = null;
                    if (product === 'pdfguru') {
                        mergedFile = 'guru_merged_full.csv';
                    } else if (product === 'pdfleader') {
                        mergedFile = 'leader_merged_full.csv';
                    } else if (product === 'thebestpdf') {
                        mergedFile = 'best_merged_full.csv';
                    }
                    
                    if (mergedFile) {
                        const mergedResponse = await fetch(mergedFile);
                        if (mergedResponse.ok) {
                            const mergedText = await mergedResponse.text();
                            const mergedLines = mergedText.split('\n').filter(l => l.trim());
                            if (mergedLines.length > 0) {
                                function parseCsv(line) {
                                    const result = [];
                                    let current = '';
                                    let inQuotes = false;
                                    for (let i = 0; i < line.length; i++) {
                                        const char = line[i];
                                        if (char === '"') {
                                            inQuotes = !inQuotes;
                                        } else if (char === ',' && !inQuotes) {
                                            result.push(current.trim());
                                            current = '';
                                        } else {
                                            current += char;
                                        }
                                    }
                                    result.push(current.trim());
                                    return result;
                                }
                                
                                const headers = parseCsv(mergedLines[0]);
                                const userIdIdx = headers.indexOf('user_id');
                                const emailIdx = headers.indexOf('gp:email');
                                
                                if (userIdIdx >= 0 && emailIdx >= 0) {
                                    if (!allProductsExtensionData[product]) {
                                        allProductsExtensionData[product] = {};
                                    }
                                    for (let i = 1; i < mergedLines.length; i++) {
                                        if (!mergedLines[i].trim()) continue;
                                        const values = parseCsv(mergedLines[i]);
                                        if (values.length > userIdIdx && values.length > emailIdx) {
                                            const userId = values[userIdIdx]?.trim();
                                            const email = values[emailIdx]?.trim();
                                            if (userId && email) {
                                                allProductsExtensionData[product][email.toLowerCase()] = userId;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    // Fallback to separate extension data file
                    if (!allProductsExtensionData[product] || Object.keys(allProductsExtensionData[product]).length === 0) {
                        const extFile = `${product}_matched_extension_data.csv`;
                        const extResponse = await fetch(extFile);
                        if (extResponse.ok) {
                            const extText = await extResponse.text();
                            const extLines = extText.split('\n').filter(l => l.trim());
                            if (extLines.length > 0) {
                                function parseCSVLine(line) {
                                    const result = [];
                                    let current = '';
                                    let inQuotes = false;
                                    for (let i = 0; i < line.length; i++) {
                                        const char = line[i];
                                        if (char === '"') {
                                            inQuotes = !inQuotes;
                                        } else if (char === ',' && !inQuotes) {
                                            result.push(current.trim());
                                            current = '';
                                        } else {
                                            current += char;
                                        }
                                    }
                                    result.push(current.trim());
                                    return result;
                                }
                                
                                const extHeaders = parseCSVLine(extLines[0]);
                                const userIdIdx = extHeaders.indexOf('user_id');
                                const emailIdx = extHeaders.indexOf('gp:email');
                                
                                if (userIdIdx >= 0 && emailIdx >= 0) {
                                    if (!allProductsExtensionData[product]) {
                                        allProductsExtensionData[product] = {};
                                    }
                                    for (let i = 1; i < extLines.length; i++) {
                                        if (!extLines[i].trim()) continue;
                                        const values = parseCSVLine(extLines[i]);
                                        if (values.length > userIdIdx && values.length > emailIdx) {
                                            const userId = values[userIdIdx]?.trim();
                                            const email = values[emailIdx]?.trim();
                                            if (userId && email) {
                                                allProductsExtensionData[product][email.toLowerCase()] = userId;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } catch (error) {
                    console.warn(`Could not load extension data for ${product}:`, error);
                }
            }
        }
        
        function handleEmailAutocomplete(event) {
            const searchInput = event.target;
            const searchTerm = searchInput.value.trim().toLowerCase();
            const autocompleteDiv = document.getElementById('emailAutocomplete');
            
            if (!autocompleteDiv) {
                console.error('Autocomplete div not found');
                return;
            }
            
            if (!searchTerm || searchTerm.length < 1) {
                hideEmailAutocomplete();
                return;
            }
            
            
            // Search in all products
            const matches = [];
            const productNames = {
                'pdfguru': 'PDFGuru',
                'pdfleader': 'PDFLeader',
                'thebestpdf': 'TheBestPDF'
            };
            
            for (const [product, emailMap] of Object.entries(allProductsExtensionData)) {
                if (!emailMap) continue;
                for (const [email, userId] of Object.entries(emailMap)) {
                    if (email && email.includes(searchTerm)) {
                        matches.push({
                            email: email,
                            userId: userId,
                            product: product,
                            productName: productNames[product] || product
                        });
                    }
                }
            }
            
            
            // Sort by relevance (exact matches first, then by email length)
            matches.sort((a, b) => {
                const aExact = a.email.startsWith(searchTerm);
                const bExact = b.email.startsWith(searchTerm);
                if (aExact && !bExact) return -1;
                if (!aExact && bExact) return 1;
                return a.email.length - b.email.length;
            });
            
            // Limit to 10 results
            const limitedMatches = matches.slice(0, 10);
            
            if (limitedMatches.length > 0) {
                showEmailAutocomplete(limitedMatches);
            } else {
                hideEmailAutocomplete();
            }
        }
        
        function showEmailAutocomplete(matches) {
            const autocompleteDiv = document.getElementById('emailAutocomplete');
            if (!autocompleteDiv) return;
            
            autocompleteDiv.innerHTML = '';
            
            matches.forEach(match => {
                const item = document.createElement('div');
                item.className = 'email-autocomplete-item';
                item.onclick = () => selectEmailFromAutocomplete(match);
                
                item.innerHTML = `
                    <div class="email-autocomplete-email">${escapeHtml(match.email)}</div>
                    <div class="email-autocomplete-product">
                        <span class="email-autocomplete-product-badge">${escapeHtml(match.productName)}</span>
                    </div>
                `;
                
                autocompleteDiv.appendChild(item);
            });
            
            autocompleteDiv.style.display = 'block';
        }
        
        function hideEmailAutocomplete() {
            const autocompleteDiv = document.getElementById('emailAutocomplete');
            if (autocompleteDiv) {
                autocompleteDiv.style.display = 'none';
            }
        }
        
        function selectEmailFromAutocomplete(match) {
            hideEmailAutocomplete();
            document.getElementById('globalSearch').value = match.email;
            
            // Switch to the product
            const productBtn = document.querySelector(`[data-product="${match.product}"]`);
            if (productBtn) {
                productBtn.click();
            }
            
            // Wait for product to load, then search for user
            setTimeout(() => {
                performGlobalSearch();
            }, 500);
        }
        
        function performGlobalSearch() {
            const searchInput = document.getElementById('globalSearch');
            const searchTerm = searchInput.value.trim().toLowerCase();
            
            hideEmailAutocomplete();
            
            if (!searchTerm) {
                return;
            }
            
            // Try to find user by ID first
            if (userMappings && userMappings[searchTerm]) {
                // Switch to user records view
                const userRecordsBtn = document.querySelector('[data-view="userrecords"]');
                if (userRecordsBtn) {
                    userRecordsBtn.click();
                }
                
                // Set search and display
                setTimeout(() => {
                    document.getElementById('userIdSearch').value = searchTerm;
                    searchUserById();
                }, 100);
                return;
            }
            
            // Try to find by email in extension data
            if (extensionData) {
                let foundUserId = null;
                for (const [userId, extData] of Object.entries(extensionData)) {
                    // Check if email matches
                    const email = extData.email || '';
                    if (email && email.toLowerCase().includes(searchTerm)) {
                        foundUserId = userId;
                        break;
                    }
                }
                
                if (foundUserId && userMappings && userMappings[foundUserId]) {
                    // Switch to user records view
                    const userRecordsBtn = document.querySelector('[data-view="userrecords"]');
                    if (userRecordsBtn) {
                        userRecordsBtn.click();
                    }
                    
                    // Set search and display
                    setTimeout(() => {
                        document.getElementById('userIdSearch').value = foundUserId;
                        searchUserById();
                    }, 100);
                    return;
                }
            }
            
            // Try to find user by ID across all products
            let foundProduct = null;
            let foundUserId = null;
            
            for (const [product, mappings] of Object.entries(allProductsUserMappings)) {
                if (mappings && mappings[searchTerm]) {
                    foundProduct = product;
                    foundUserId = searchTerm;
                    break;
                }
            }
            
            // If not found by exact ID, try to find by email across all products
            if (!foundUserId) {
                for (const [product, emailMap] of Object.entries(allProductsExtensionData)) {
                    if (!emailMap) continue;
                    for (const [email, userId] of Object.entries(emailMap)) {
                        if (email && email.toLowerCase().includes(searchTerm)) {
                            // Find which product has this user
                            for (const [prod, mappings] of Object.entries(allProductsUserMappings)) {
                                if (mappings && mappings[userId]) {
                                    foundProduct = prod;
                                    foundUserId = userId;
                                    break;
                                }
                            }
                            if (foundUserId) break;
                        }
                    }
                    if (foundUserId) break;
                }
            }
            
            if (foundUserId && foundProduct) {
                // Switch to the found product
                const productBtn = document.querySelector(`[data-product="${foundProduct}"]`);
                if (productBtn && currentProduct !== foundProduct) {
                    productBtn.click();
                    // Wait for product to load, then switch to user records
                    setTimeout(() => {
                        switchToUserRecordsAndSearch(foundUserId);
                    }, 1500);
                } else {
                    // Already on the correct product
                    switchToUserRecordsAndSearch(foundUserId);
                }
            } else {
                // Not found - show message
                showNotification(`No user found matching "${searchTerm}". Please check the User ID or Email and try again.`, 'error');
            }
        }
        
        function switchToUserRecordsAndSearch(userId) {
            // Switch to user records view
            const userRecordsBtn = document.querySelector('[data-view="userrecords"]');
            if (userRecordsBtn) {
                userRecordsBtn.click();
            }
            
            // Set search and display
            setTimeout(() => {
                document.getElementById('userIdSearch').value = userId;
                searchUserById();
            }, 100);
        }

        function renderLevel1View() {
            // Check if the view panel is active (check parent panel, not the chart view itself)
            const parentPanel = document.getElementById('level1');
            if (!parentPanel || !parentPanel.classList.contains('active')) {
                // View is not active, don't render
                return;
            }
            
            // Get the chart view panel
            let level1Panel = document.getElementById('level1ChartView');
            
            // If panel doesn't exist or was cleared, restore its structure
            if (!level1Panel) {
                // Panel was removed, recreate it
                level1Panel = document.createElement('div');
                level1Panel.id = 'level1ChartView';
                
                // Find where to insert it (after level-selector, before level1TableView)
                const levelSelector = parentPanel.querySelector('.level-selector');
                const level1TableView = parentPanel.querySelector('#level1TableView');
                
                if (levelSelector && levelSelector.nextSibling) {
                    parentPanel.insertBefore(level1Panel, levelSelector.nextSibling);
                } else if (level1TableView) {
                    parentPanel.insertBefore(level1Panel, level1TableView);
                } else {
                    parentPanel.appendChild(level1Panel);
                }
            }
            
            // If panel was cleared (empty innerHTML or contains only empty-state), restore its structure
            if (level1Panel && (level1Panel.innerHTML.trim() === '' || level1Panel.querySelector('.empty-state'))) {
                // Restore the panel structure from the original HTML
                level1Panel.innerHTML = `
                    <div class="chart-container">
                        <div class="chart-wrapper">
                            <div class="chart-loader" id="chartLoader">
                                <div class="chart-loader-spinner"></div>
                                <div class="chart-loader-text" id="chartLoaderText">Loading data...</div>
                                <div class="chart-loader-subtext" id="chartLoaderSubtext">Please wait</div>
                            </div>
                            <canvas id="level1PieChart"></canvas>
                            <div id="tooltip" class="tooltip"></div>
                            <div class="chart-stats-overlay">
                                <div class="chart-stat-item">
                                    <strong>Total Records:</strong> <span id="totalRecords">-</span>
                                </div>
                                <div class="chart-stat-item">
                                    <strong>Level 1 Categories:</strong> <span id="level1Count">-</span>
                                </div>
                            </div>
                        </div>
                        <div class="chart-legend" id="level1Legend">
                            <div class="legend-title">Categories</div>
                            <div id="level1LegendContent"></div>
                        </div>
                    </div>
                    <div class="category-list" id="level1List"></div>
                `;
            }
            
            if (!currentData || !currentData.level1_distribution) {
                console.warn('No data available for Level 1 view');
                return;
            }
            
            const data = currentData.level1_distribution;
            const entries = Object.entries(data).sort((a, b) => b[1].count - a[1].count);
            
            // If no entries, show empty state
            if (entries.length === 0) {
                const canvas = document.getElementById('level1PieChart');
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
                const legendContainer = document.getElementById('level1LegendContent');
                if (legendContainer) {
                    legendContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: #6c757d;">No data available</div>';
                }
                const listContainer = document.getElementById('level1List');
                if (listContainer) {
                    listContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: #6c757d;">No data available</div>';
                }
                return;
            }
            
            // Assign colors based on popularity (most popular = brightest colors)
            // This ensures consistency: once a category gets a color, it keeps it across products
            const colors = assignColorsByPopularity(entries);
            
            // Render pie chart with colors and click handler
            const canvas = document.getElementById('level1PieChart');
            if (!canvas) {
                console.warn('level1PieChart element not found');
                return;
            }
            renderPieChart('level1PieChart', entries, (segment) => {
                const level2Data = currentData.level2_by_level1[segment.category] || {};
                const handwritten = currentData.handwritten_analysis[segment.category] || {};
                const level2Count = Object.keys(level2Data).length;
                
                return `
                    <div class="tooltip-title">${escapeHtml(segment.category)}</div>
                    <div class="tooltip-line"><strong>Count:</strong> ${segment.info.count.toLocaleString()} records</div>
                    <div class="tooltip-line"><strong>Percentage:</strong> ${segment.info.percentage}% of total</div>
                    <div class="tooltip-section">
                        <div class="tooltip-section-title">Level 2 Categories:</div>
                        <div class="tooltip-line">${level2Count} subcategories</div>
                    </div>
                    <div class="tooltip-section">
                        <div class="tooltip-section-title">Handwritten Text:</div>
                        <div class="tooltip-line">${handwritten.with_handwritten || 0} documents (${handwritten.percentage || 0}%)</div>
                    </div>
                    <div class="tooltip-section" style="margin-top: 10px; padding-top: 10px; border-top: 2px solid rgba(255,255,255,0.4);">
                        <div class="tooltip-line" style="font-size: 11px; color: #a8d8ff;">Click for detailed statistics</div>
                    </div>
                `;
            }, 'tooltip', colors);
            
            // Add click handler to canvas
            if (canvas) {
                canvas.onclick = function(e) {
                    const rect = canvas.getBoundingClientRect();
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;
                    const x = (e.clientX - rect.left) * scaleX;
                    const y = (e.clientY - rect.top) * scaleY;
                    
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    const radius = (canvas.width / 2) - 20;
                    
                    const dx = x - centerX;
                    const dy = y - centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < radius) {
                        const angle = Math.atan2(dy, dx);
                        let normalizedAngle = angle;
                        if (normalizedAngle < -Math.PI / 2) normalizedAngle += 2 * Math.PI;
                        normalizedAngle += Math.PI / 2;
                        
                        const clicked = canvas.segments.find(seg => {
                            let segStart = seg.startAngle;
                            let segEnd = seg.endAngle;
                            if (segStart < -Math.PI / 2) segStart += 2 * Math.PI;
                            if (segEnd < -Math.PI / 2) segEnd += 2 * Math.PI;
                            segStart += Math.PI / 2;
                            segEnd += Math.PI / 2;
                            return normalizedAngle >= segStart && normalizedAngle <= segEnd;
                        });
                        
                        if (clicked) {
                            showDetailedStats(clicked.category);
                        }
                    }
                };
            }
            
            // Render legend with percentages
            const legendContainer = document.getElementById('level1LegendContent');
            if (!legendContainer) {
                console.warn('level1LegendContent element not found');
                return;
            }
            
            legendContainer.innerHTML = entries.map(([category, info], index) => `
                <div class="legend-item" data-category="${escapeHtml(category)}">
                    <div class="legend-color" style="background-color: ${colors[index]}"></div>
                    <div class="legend-text">
                        <div class="legend-name">${escapeHtml(category)}</div>
                        <div class="legend-percentage">${info.percentage}% (${info.count.toLocaleString()} records)</div>
                    </div>
                </div>
            `).join('');
            
            // Add click handler to legend items to highlight segments
            legendContainer.querySelectorAll('.legend-item').forEach(item => {
                item.addEventListener('click', () => {
                    const category = item.dataset.category;
                    // Scroll to the category card in the list
                    const card = Array.from(document.querySelectorAll('.category-card')).find(c => 
                        c.querySelector('.category-name').textContent === category
                    );
                    if (card) {
                        card.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        card.style.borderColor = '#667eea';
                        card.style.boxShadow = '0 4px 12px rgba(102, 126, 234, 0.4)';
                        setTimeout(() => {
                            card.style.borderColor = '';
                            card.style.boxShadow = '';
                        }, 2000);
                    }
                });
            });

            // Render list
            const listContainer = document.getElementById('level1List');
            if (!listContainer) {
                console.warn('level1List element not found');
                return;
            }
            
            listContainer.innerHTML = entries.map(([category, info]) => {
                const handwritten = currentData.handwritten_analysis[category] || {};
                const scanPhoto = currentData.scan_photo_analysis[category] || {};
                const personalData = currentData.personal_data_analysis[category] || {};
                const level2Count = Object.keys(currentData.level2_by_level1[category] || {}).length;
                
                return `
                    <div class="category-card" onclick="showDetailedStats('${escapeHtml(category).replace(/'/g, "\\'")}')" style="cursor: pointer;">
                        <div class="category-header">
                            <div class="category-name">${escapeHtml(category)}</div>
                            <div class="category-count">${info.count.toLocaleString()}</div>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Percentage:</span>
                            <span class="metric-value">${info.percentage}%</span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${info.percentage}%; background: linear-gradient(90deg, ${getCategoryColor(category)} 0%, ${getCategoryColor(category)} 100%);"></div>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Level 2 Categories:</span>
                            <span class="metric-value">${level2Count}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Handwritten Text:</span>
                            <span class="metric-value">${handwritten.percentage || 0}%</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Personal Data:</span>
                            <span class="metric-value">${personalData.percentage || 0}%</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Scans/Photos:</span>
                            <span class="metric-value">${scanPhoto.percentage || 0}%</span>
                        </div>
                    </div>
                `;
            }).join('');
            
            // Render comparison table
            renderLevel1ComparisonTable(entries);
            // Update sort indicators after rendering
            setTimeout(() => updateSortIndicators(), 100);
        }

        function switchLevel1View(view) {
            level1TableView = view;
            document.querySelectorAll('[data-view]').forEach(btn => {
                if (btn.dataset.view) {
                    btn.classList.toggle('active', btn.dataset.view === view);
                }
            });
            document.getElementById('level1ChartView').style.display = view === 'chart' ? 'block' : 'none';
            document.getElementById('level1TableView').style.display = view === 'table' ? 'block' : 'none';
            saveState();
        }

        function renderLevel1ComparisonTable(entries) {
            const tbody = document.getElementById('level1TableBody');
            if (!tbody) {
                console.warn('level1TableBody element not found');
                return;
            }
            const maxCount = Math.max(...entries.map(([, info]) => info.count));
            const maxPercentage = Math.max(...entries.map(([, info]) => info.percentage));
            
            tbody.innerHTML = entries.map(([category, info], index) => {
                const handwritten = currentData.handwritten_analysis[category] || {};
                const personalData = currentData.personal_data_analysis[category] || {};
                const scanPhoto = currentData.scan_photo_analysis[category] || {};
                const level2Count = Object.keys(currentData.level2_by_level1[category] || {}).length;
                
                const handwrittenPct = handwritten.percentage || 0;
                const personalPct = personalData.percentage || 0;
                const scanPhotoPct = scanPhoto.percentage || 0;
                
                return `
                    <tr onclick="showDetailedStats('${escapeHtml(category).replace(/'/g, "\\'")}')" style="cursor: pointer;">
                        <td><strong>#${index + 1}</strong></td>
                        <td><strong>${escapeHtml(category)}</strong></td>
                        <td>${info.count.toLocaleString()}</td>
                        <td>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span style="min-width: 60px;">${info.percentage}%</span>
                                <div class="comparison-bar">
                                    <div class="comparison-bar-fill" style="width: ${(info.percentage / maxPercentage) * 100}%; background: linear-gradient(90deg, ${getCategoryColor(category)} 0%, ${getCategoryColor(category)} 100%);"></div>
                                </div>
                            </div>
                        </td>
                        <td>${level2Count}</td>
                        <td>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span style="min-width: 50px;">${handwrittenPct}%</span>
                                <div class="comparison-bar">
                                    <div class="comparison-bar-fill" style="width: ${handwrittenPct}%"></div>
                                </div>
                            </div>
                        </td>
                        <td>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span style="min-width: 50px; color: ${personalPct >= 50 ? '#e74c3c' : personalPct >= 25 ? '#f39c12' : '#667eea'};">${personalPct}%</span>
                                <div class="comparison-bar">
                                    <div class="comparison-bar-fill" style="width: ${personalPct}%; background: ${personalPct >= 50 ? 'linear-gradient(90deg, #e74c3c 0%, #c0392b 100%)' : personalPct >= 25 ? 'linear-gradient(90deg, #f39c12 0%, #e67e22 100%)' : 'linear-gradient(90deg, #667eea 0%, #764ba2 100%)'};"></div>
                                </div>
                            </div>
                        </td>
                        <td>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span style="min-width: 50px;">${scanPhotoPct}%</span>
                                <div class="comparison-bar">
                                    <div class="comparison-bar-fill" style="width: ${scanPhotoPct}%"></div>
                                </div>
                            </div>
                        </td>
                    </tr>
                `;
            }).join('');
        }

        function filterLevel1Table() {
            const sortBy = level1TableSort;
            const data = currentData.level1_distribution;
            let entries = Object.entries(data);
            
            // Sort
            const [field, direction] = sortBy.split('-');
            entries.sort((a, b) => {
                let comparison = 0;
                if (field === 'count') {
                    comparison = a[1].count - b[1].count;
                } else if (field === 'percentage') {
                    comparison = a[1].percentage - b[1].percentage;
                } else if (field === 'handwritten') {
                    const aHw = currentData.handwritten_analysis[a[0]]?.percentage || 0;
                    const bHw = currentData.handwritten_analysis[b[0]]?.percentage || 0;
                    comparison = aHw - bHw;
                } else if (field === 'personal') {
                    const aPd = currentData.personal_data_analysis[a[0]]?.percentage || 0;
                    const bPd = currentData.personal_data_analysis[b[0]]?.percentage || 0;
                    comparison = aPd - bPd;
                } else if (field === 'name') {
                    comparison = a[0].localeCompare(b[0]);
                }
                return direction === 'desc' ? -comparison : comparison;
            });
            
            renderLevel1ComparisonTable(entries);
            level1TableSort = sortBy;
            updateSortIndicators();
            saveState();
        }

        function sortTable(field) {
            const data = currentData.level1_distribution;
            let entries = Object.entries(data);
            
            // Toggle sort direction if clicking same field
            const currentSort = level1TableSort.split('-');
            if (currentSort[0] === field) {
                level1TableSort = currentSort[1] === 'desc' ? `${field}-asc` : `${field}-desc`;
            } else {
                level1TableSort = `${field}-desc`;
            }
            
            // Update header sort indicators
            updateSortIndicators();
            
            saveState();
            filterLevel1Table();
        }
        
        function updateSortIndicators() {
            // Remove all sort classes from headers
            document.querySelectorAll('#level1ComparisonTable th').forEach(th => {
                th.classList.remove('sort-asc', 'sort-desc');
            });
            
            // Add sort class to active header
            const [field, direction] = level1TableSort.split('-');
            const fieldMap = {
                'rank': 0,
                'name': 1,
                'count': 2,
                'percentage': 3,
                'level2': 4,
                'handwritten': 5,
                'personal': 6,
                'scanphoto': 7
            };
            
            const headerIndex = fieldMap[field];
            if (headerIndex !== undefined) {
                const headers = document.querySelectorAll('#level1ComparisonTable th');
                if (headers[headerIndex]) {
                    headers[headerIndex].classList.add(direction === 'asc' ? 'sort-asc' : 'sort-desc');
                }
            }
        }

        function renderLevel2View() {
            const selector = document.getElementById('level1Selector');
            let selectedCategory = selector.value;
            
            // Auto-select first category if none selected
            if (!selectedCategory && selector.options.length > 1) {
                selectedCategory = selector.options[1].value;
                selector.value = selectedCategory;
            }
            
            if (!selectedCategory) {
                document.getElementById('level2List').innerHTML = '<div class="empty-state">Please select a Level 1 category</div>';
                const canvas = document.getElementById('level2PieChart');
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
                return;
            }
            
            const level2Data = currentData.level2_by_level1[selectedCategory] || {};
            const entries = Object.entries(level2Data).sort((a, b) => b[1].count - a[1].count);

            if (entries.length === 0) {
                document.getElementById('level2List').innerHTML = `<div class="empty-state">No Level 2 categories found for "${selectedCategory}"</div>`;
                const canvas = document.getElementById('level2PieChart');
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
                return;
            }

            // Generate colors for level 2 chart
            // Assign colors based on popularity for Level 2 categories
            const colors = assignColorsByPopularity(entries);
            
            renderPieChart('level2PieChart', entries, (segment) => {
                return `
                    <div class="tooltip-title">${escapeHtml(segment.category)}</div>
                    <div class="tooltip-line"><strong>Count:</strong> ${segment.info.count.toLocaleString()} records</div>
                    <div class="tooltip-line"><strong>Percentage:</strong> ${segment.info.percentage}% of ${selectedCategory}</div>
                `;
            }, 'tooltip2', colors);
            
            // Render legend for Level 2
            const legendContainer = document.getElementById('level2LegendContent');
            legendContainer.innerHTML = entries.map(([category, info], index) => `
                <div class="legend-item" data-category="${escapeHtml(category)}">
                    <div class="legend-color" style="background-color: ${colors[index]}"></div>
                    <div class="legend-text">
                        <div class="legend-name">${escapeHtml(category)}</div>
                        <div class="legend-percentage">${info.percentage}% (${info.count.toLocaleString()} records)</div>
                    </div>
                </div>
            `).join('');

            const listContainer = document.getElementById('level2List');
            listContainer.innerHTML = entries.map(([category, info]) => `
                <div class="category-card">
                    <div class="category-header">
                        <div class="category-name">${escapeHtml(category)}</div>
                        <div class="category-count">${info.count.toLocaleString()}</div>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Percentage:</span>
                        <span class="metric-value">${info.percentage}%</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${info.percentage}%"></div>
                    </div>
                </div>
            `).join('');

            // Update display text for selected option after rendering
            const selectedOption = selector.options[selector.selectedIndex];
            if (selectedOption && selectedOption.value) {
                const fullText = selectedOption.getAttribute('data-full-text') || selectedOption.textContent;
                const categoryName = fullText.split(' - ')[0];
                selectedOption.textContent = categoryName;
            }
        }

        function renderHandwrittenView() {
            const data = currentData.handwritten_analysis;
            // Sort by total docs (descending) - most popular first
            const entries = Object.entries(data).sort((a, b) => b[1].total - a[1].total);
            
            // Calculate summary statistics
            const totalDocs = Object.values(data).reduce((sum, d) => sum + d.total, 0);
            const totalWithHandwritten = Object.values(data).reduce((sum, d) => sum + d.with_handwritten, 0);
            const avgPercentage = Object.values(data).reduce((sum, d) => sum + d.percentage, 0) / entries.length;
            const categoriesWith100 = entries.filter(([, d]) => d.percentage === 100).length;
            const categoriesWith0 = entries.filter(([, d]) => d.percentage === 0).length;
            const categoriesAboveAvg = entries.filter(([, d]) => d.percentage > avgPercentage).length;
            const top5Categories = entries.slice(0, 5);
            const bottom5Categories = entries.slice(-5).reverse();
            
            const listContainer = document.getElementById('handwrittenList');
            listContainer.innerHTML = `
                <div class="analysis-summary">
                    <h2>üìù Handwritten Text Analysis</h2>
                    <div class="summary-metrics">
                        <div class="summary-metric">
                            <div class="summary-metric-label">Total Documents Analyzed</div>
                            <div class="summary-metric-value">${totalDocs.toLocaleString()}</div>
                        </div>
                        <div class="summary-metric">
                            <div class="summary-metric-label">Documents with Handwriting</div>
                            <div class="summary-metric-value">${totalWithHandwritten.toLocaleString()}</div>
                        </div>
                        <div class="summary-metric">
                            <div class="summary-metric-label">Average Percentage</div>
                            <div class="summary-metric-value">${avgPercentage.toFixed(1)}%</div>
                        </div>
                        <div class="summary-metric">
                            <div class="summary-metric-label">Categories with 100%</div>
                            <div class="summary-metric-value">${categoriesWith100}</div>
                        </div>
                    </div>
                    
                </div>
                
                <div id="handwrittenTableContainer" style="margin-top: 20px;">
                    <table class="data-table" id="handwrittenTable" style="width: 100%;">
                        <thead>
                            <tr>
                                <th onclick="sortHandwrittenTable('rank')">Rank</th>
                                <th onclick="sortHandwrittenTable('name')">Category</th>
                                <th onclick="sortHandwrittenTable('total')">Total Docs</th>
                                <th onclick="sortHandwrittenTable('with')">With Handwriting</th>
                                <th onclick="sortHandwrittenTable('without')">Without Handwriting</th>
                                <th onclick="sortHandwrittenTable('percentage')">Percentage</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${entries.map(([category, info], idx) => `
                                <tr>
                                    <td><strong>#${idx + 1}</strong></td>
                                    <td><strong style="color: #212529;">${escapeHtml(category)}</strong></td>
                                    <td style="color: #212529;">${info.total.toLocaleString()}</td>
                                    <td style="color: #212529;">${info.with_handwritten.toLocaleString()}</td>
                                    <td style="color: #212529;">${(info.total - info.with_handwritten).toLocaleString()}</td>
                                    <td>
                                        <div style="display: flex; align-items: center; gap: 10px;">
                                            <span style="min-width: 60px; color: #212529;">${info.percentage}%</span>
                                            <div class="comparison-bar">
                                                <div class="comparison-bar-fill" style="width: ${info.percentage}%; background: linear-gradient(90deg, ${getCategoryColor(category)} 0%, ${getCategoryColor(category)} 100%);"></div>
                                            </div>
                                        </div>
                                    </td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            
            // Initialize sort indicators
            updateHandwrittenSortIndicators();
        }
        
        function sortHandwrittenTable(field) {
            const data = currentData.handwritten_analysis;
            let entries = Object.entries(data);
            
            // Toggle sort direction if clicking same field
            const currentSort = handwrittenTableSort.split('-');
            if (currentSort[0] === field) {
                handwrittenTableSort = currentSort[1] === 'desc' ? `${field}-asc` : `${field}-desc`;
            } else {
                handwrittenTableSort = `${field}-desc`;
            }
            
            // Sort entries
            const [sortField, direction] = handwrittenTableSort.split('-');
            entries.sort((a, b) => {
                let comparison = 0;
                if (sortField === 'rank' || sortField === 'name') {
                    comparison = a[0].localeCompare(b[0]);
                } else if (sortField === 'total') {
                    comparison = a[1].total - b[1].total;
                } else if (sortField === 'with') {
                    comparison = a[1].with_handwritten - b[1].with_handwritten;
                } else if (sortField === 'without') {
                    comparison = (a[1].total - a[1].with_handwritten) - (b[1].total - b[1].with_handwritten);
                } else if (sortField === 'percentage') {
                    comparison = a[1].percentage - b[1].percentage;
                }
                return direction === 'desc' ? -comparison : comparison;
            });
            
            // Update table
            const tbody = document.querySelector('#handwrittenTable tbody');
            if (tbody) {
                tbody.innerHTML = entries.map(([category, info], idx) => `
                    <tr>
                        <td><strong>#${idx + 1}</strong></td>
                        <td><strong>${escapeHtml(category)}</strong></td>
                        <td>${info.total.toLocaleString()}</td>
                        <td>${info.with_handwritten.toLocaleString()}</td>
                        <td>${(info.total - info.with_handwritten).toLocaleString()}</td>
                        <td>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span style="min-width: 60px;">${info.percentage}%</span>
                                <div class="comparison-bar">
                                    <div class="comparison-bar-fill" style="width: ${info.percentage}%; background: ${info.percentage >= 75 ? 'linear-gradient(90deg, #28a745 0%, #20c997 100%)' : info.percentage >= 50 ? 'linear-gradient(90deg, #ffc107 0%, #ff9800 100%)' : info.percentage >= 25 ? 'linear-gradient(90deg, #fd7e14 0%, #dc3545 100%)' : 'linear-gradient(90deg, #6c757d 0%, #495057 100%)'};"></div>
                                </div>
                            </div>
                        </td>
                    </tr>
                `).join('');
            }
            
            // Update sort indicators
            updateHandwrittenSortIndicators();
        }
        
        function updateHandwrittenSortIndicators() {
            document.querySelectorAll('#handwrittenTable th').forEach(th => {
                th.classList.remove('sort-asc', 'sort-desc');
            });
            const [field, direction] = handwrittenTableSort.split('-');
            const fieldMap = { 'rank': 0, 'name': 1, 'total': 2, 'with': 3, 'without': 4, 'percentage': 5 };
            const headerIndex = fieldMap[field];
            if (headerIndex !== undefined) {
                const headers = document.querySelectorAll('#handwrittenTable th');
                if (headers[headerIndex]) {
                    headers[headerIndex].classList.add(direction === 'asc' ? 'sort-asc' : 'sort-desc');
                }
            }
        }

        function filterHandwritten() {
            const sortBy = 'percentage-desc'; // Default sort
            const data = currentData.handwritten_analysis;
            let entries = Object.entries(data);
            
            // Sort
            const [field, direction] = sortBy.split('-');
            entries.sort((a, b) => {
                let comparison = 0;
                if (field === 'percentage') {
                    comparison = a[1].percentage - b[1].percentage;
                } else if (field === 'count') {
                    comparison = a[1].with_handwritten - b[1].with_handwritten;
                } else if (field === 'name') {
                    comparison = a[0].localeCompare(b[0]);
                }
                return direction === 'desc' ? -comparison : comparison;
            });
            
            // Update display
            const container = document.getElementById('handwrittenCards');
            container.innerHTML = entries.map(([category, info]) => `
                <div class="analysis-card" data-category="${escapeHtml(category)}">
                    <div class="analysis-card-header">
                        <div>
                            <div class="analysis-card-title">${escapeHtml(category)}</div>
                            <div style="color: #6c757d; margin-top: 5px; font-size: 0.9em;">
                                ${info.total.toLocaleString()} total documents
                            </div>
                        </div>
                        <div class="analysis-card-stats">
                            <div class="analysis-stat">
                                <span class="analysis-stat-value">${info.percentage}%</span>
                                <span class="analysis-stat-label">Handwritten</span>
                            </div>
                            <div class="analysis-stat">
                                <span class="analysis-stat-value">${info.with_handwritten}</span>
                                <span class="analysis-stat-label">Documents</span>
                            </div>
                        </div>
                    </div>
                    <div class="percentage-display">
                        <div class="percentage-value">${info.percentage}%</div>
                        <div class="percentage-details">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                                <span style="color: #6c757d;">With handwritten text: ${info.with_handwritten.toLocaleString()}</span>
                                <span style="color: #6c757d;">Without: ${(info.total - info.with_handwritten).toLocaleString()}</span>
                            </div>
                            <div class="percentage-bar-large">
                                <div class="percentage-fill-large" style="width: ${info.percentage}%; background: linear-gradient(90deg, ${getCategoryColor(category)} 0%, ${getCategoryColor(category)} 100%);"></div>
                            </div>
                        </div>
                    </div>
                </div>
            `).join('');
        }

        function renderImageTypesView() {
            const data = currentData.image_types_analysis;
            
            // Calculate summary across all categories
            let allImageTypes = new Set();
            let totalDocs = 0;
            
            Object.entries(data).forEach(([category, types]) => {
                Object.keys(types).forEach(type => allImageTypes.add(type));
                const level1Data = currentData.level1_distribution[category] || {};
                totalDocs += level1Data.count || 0;
            });
            
            // Build entries: aggregate image types across all categories by category
            // Group by category, then show image types per category (like scan/photo shows scan types per category)
            const categoryEntries = Object.entries(data)
                .map(([category, types]) => {
                    const level1Data = currentData.level1_distribution[category] || {};
                    const totalCategoryDocs = level1Data.count || 0;
                    const imageTypeEntries = Object.entries(types)
                        .sort((a, b) => b[1].documents_with_type - a[1].documents_with_type)
                        .slice(0, 3)
                        .map(([type, typeInfo]) => `${type.replace(/_/g, ' ')} (${typeInfo.documents_with_type})`)
                        .join(', ') || 'N/A';
                    
                    // Calculate documents with images: count unique documents that have at least one image type
                    // Since we can't count unique documents from the aggregated data, we use the maximum
                    // documents_with_type value as an approximation (a document with multiple types will be counted
                    // multiple times in different types, but the max gives us a lower bound)
                    // For accurate count, we'd need to track this during data preparation
                    const imageTypeValues = Object.values(types).filter(v => typeof v === 'object' && v.documents_with_type !== undefined);
                    let docsWithImages = 0;
                    
                    if (types._docsWithImages !== undefined) {
                        // Use the unique count from filtered data (when filters are applied)
                        docsWithImages = types._docsWithImages;
                    } else if (imageTypeValues.length > 0) {
                        // For original data: use the maximum as approximation
                        // This is not perfect but better than summing (which would overcount)
                        const maxDocs = Math.max(...imageTypeValues.map(v => v.documents_with_type), 0);
                        docsWithImages = maxDocs;
                    }
                    
                    const percentage = totalCategoryDocs > 0 ? ((docsWithImages / totalCategoryDocs) * 100).toFixed(2) : 0;
                    
                    return [category, {
                        total: totalCategoryDocs,
                        image_types: imageTypeEntries,
                        total_types: Object.keys(types).length,
                        with_images: docsWithImages,
                        percentage: parseFloat(percentage)
                    }];
                })
                .sort((a, b) => b[1].total - a[1].total); // Sort by total docs
            
            const listContainer = document.getElementById('imageTypesList');
            if (!listContainer) {
                console.warn('imageTypesList element not found');
                return;
            }
            
            listContainer.innerHTML = `
                <div class="analysis-summary">
                    <h2>üñºÔ∏è Image Types Analysis</h2>
                    <div class="summary-metrics">
                        <div class="summary-metric">
                            <div class="summary-metric-label">Total Image Types</div>
                            <div class="summary-metric-value">${allImageTypes.size}</div>
                        </div>
                        <div class="summary-metric">
                            <div class="summary-metric-label">Total Documents</div>
                            <div class="summary-metric-value">${totalDocs.toLocaleString()}</div>
                        </div>
                        <div class="summary-metric">
                            <div class="summary-metric-label">Categories</div>
                            <div class="summary-metric-value">${categoryEntries.length}</div>
                        </div>
                    </div>
                </div>
                
                <div id="imageTypesTableContainer" style="margin-top: 20px;">
                    <table class="data-table" id="imageTypesTable" style="width: 100%;">
                        <thead>
                            <tr>
                                <th onclick="sortImageTypesTable('rank')">Rank</th>
                                <th onclick="sortImageTypesTable('name')">Category</th>
                                <th onclick="sortImageTypesTable('total')">Total Docs</th>
                                <th onclick="sortImageTypesTable('percentage')">Percentage</th>
                                <th onclick="sortImageTypesTable('types')">Image Types</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${categoryEntries.map(([category, info], idx) => `
                                <tr>
                                    <td><strong>#${idx + 1}</strong></td>
                                    <td><strong style="color: #212529;">${escapeHtml(category)}</strong></td>
                                    <td style="color: #212529;">${info.total.toLocaleString()}</td>
                                    <td>
                                        <div style="display: flex; align-items: center; gap: 10px;">
                                            <span style="min-width: 60px; color: #212529;">${info.percentage.toFixed(1)}%</span>
                                            <div class="comparison-bar">
                                                <div class="comparison-bar-fill" style="width: ${info.percentage}%; background: linear-gradient(90deg, ${getCategoryColor(category)} 0%, ${getCategoryColor(category)} 100%);"></div>
                                            </div>
                                        </div>
                                    </td>
                                    <td style="color: #212529; font-size: 13px;">${escapeHtml(info.image_types)}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;

            // Initialize sort indicators
            updateImageTypesSortIndicators();
        }
        
        function sortImageTypesTable(field) {
            const data = currentData.image_types_analysis;
            
            // Build category entries (same as renderImageTypesView)
            let categoryEntries = Object.entries(data)
                .map(([category, types]) => {
                    const level1Data = currentData.level1_distribution[category] || {};
                    const totalCategoryDocs = level1Data.count || 0;
                    const imageTypeEntries = Object.entries(types)
                        .sort((a, b) => b[1].documents_with_type - a[1].documents_with_type)
                        .slice(0, 3)
                        .map(([type, typeInfo]) => `${type.replace(/_/g, ' ')} (${typeInfo.documents_with_type})`)
                        .join(', ') || 'N/A';
                    
                    // Calculate documents with images: sum of all documents_with_type
                    const docsWithImages = Object.values(types).reduce((sum, typeInfo) => sum + typeInfo.documents_with_type, 0);
                    const percentage = totalCategoryDocs > 0 ? ((docsWithImages / totalCategoryDocs) * 100).toFixed(2) : 0;
                    
                    return [category, {
                        total: totalCategoryDocs,
                        image_types: imageTypeEntries,
                        total_types: Object.keys(types).length,
                        with_images: docsWithImages,
                        percentage: parseFloat(percentage)
                    }];
                });
            
            // Default sort by total docs (descending)
            categoryEntries.sort((a, b) => b[1].total - a[1].total);
            
            // Toggle sort direction if clicking same field
            if (!window.imageTypesTableSort) window.imageTypesTableSort = 'total-desc';
            const currentSort = window.imageTypesTableSort.split('-');
            if (currentSort[0] === field) {
                window.imageTypesTableSort = currentSort[1] === 'desc' ? `${field}-asc` : `${field}-desc`;
            } else {
                window.imageTypesTableSort = `${field}-desc`;
            }
            
            // Sort entries
            const [sortField, direction] = window.imageTypesTableSort.split('-');
            categoryEntries.sort((a, b) => {
                let comparison = 0;
                if (sortField === 'rank' || sortField === 'name') {
                    comparison = a[0].localeCompare(b[0]);
                } else if (sortField === 'total') {
                    comparison = a[1].total - b[1].total;
                } else if (sortField === 'percentage') {
                    comparison = a[1].percentage - b[1].percentage;
                } else if (sortField === 'types') {
                    comparison = a[1].total_types - b[1].total_types;
                }
                return direction === 'desc' ? -comparison : comparison;
            });
            
            // Update table
            const tbody = document.querySelector('#imageTypesTable tbody');
            if (tbody) {
                tbody.innerHTML = categoryEntries.map(([category, info], idx) => `
                    <tr>
                        <td><strong>#${idx + 1}</strong></td>
                        <td><strong style="color: #212529;">${escapeHtml(category)}</strong></td>
                        <td style="color: #212529;">${info.total.toLocaleString()}</td>
                        <td>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span style="min-width: 60px; color: #212529;">${info.percentage.toFixed(1)}%</span>
                                <div class="comparison-bar">
                                    <div class="comparison-bar-fill" style="width: ${info.percentage}%; background: linear-gradient(90deg, ${getCategoryColor(category)} 0%, ${getCategoryColor(category)} 100%);"></div>
                                </div>
                            </div>
                        </td>
                        <td style="color: #212529; font-size: 13px;">${escapeHtml(info.image_types)}</td>
                    </tr>
                `).join('');
            }
            
            // Update sort indicators
            updateImageTypesSortIndicators();
        }
        
        function updateImageTypesSortIndicators() {
            if (!window.imageTypesTableSort) window.imageTypesTableSort = 'total-desc';
            document.querySelectorAll('#imageTypesTable th').forEach(th => {
                th.classList.remove('sort-asc', 'sort-desc');
            });
            const [field, direction] = window.imageTypesTableSort.split('-');
            const fieldMap = { 'rank': 0, 'name': 1, 'total': 2, 'percentage': 3, 'types': 4 };
            const headerIndex = fieldMap[field];
            if (headerIndex !== undefined) {
                const headers = document.querySelectorAll('#imageTypesTable th');
                if (headers[headerIndex]) {
                    headers[headerIndex].classList.add(direction === 'asc' ? 'sort-asc' : 'sort-desc');
                }
            }
        }


        function renderScanPhotoView() {
            const data = currentData.scan_photo_analysis;
            // Sort by total docs (descending) - most popular first
            const entries = Object.entries(data).sort((a, b) => b[1].total - a[1].total);
            
            // Calculate summary
            const totalDocs = Object.values(data).reduce((sum, d) => sum + d.total, 0);
            const totalScans = Object.values(data).reduce((sum, d) => sum + d.scans_or_photos, 0);
            const totalDigital = totalDocs - totalScans;
            const avgPercentage = Object.values(data).reduce((sum, d) => sum + d.percentage, 0) / entries.length;
            const categoriesAboveAvg = entries.filter(([, d]) => d.percentage > avgPercentage).length;
            const categoriesWith100 = entries.filter(([, d]) => d.percentage === 100).length;
            const categoriesWith0 = entries.filter(([, d]) => d.percentage === 0).length;
            const top5Categories = entries.slice(0, 5);
            
            const listContainer = document.getElementById('scanPhotoList');
            listContainer.innerHTML = `
                <div class="analysis-summary">
                    <h2>üì∑ Scan/Photo Analysis</h2>
                    <div class="summary-metrics">
                        <div class="summary-metric">
                            <div class="summary-metric-label">Total Documents</div>
                            <div class="summary-metric-value">${totalDocs.toLocaleString()}</div>
                        </div>
                        <div class="summary-metric">
                            <div class="summary-metric-label">Scans/Photos</div>
                            <div class="summary-metric-value">${totalScans.toLocaleString()}</div>
                        </div>
                        <div class="summary-metric">
                            <div class="summary-metric-label">Digital Documents</div>
                            <div class="summary-metric-value">${totalDigital.toLocaleString()}</div>
                        </div>
                        <div class="summary-metric">
                            <div class="summary-metric-label">Average Percentage</div>
                            <div class="summary-metric-value">${avgPercentage.toFixed(1)}%</div>
                        </div>
                    </div>
                    
                </div>
                
                <div id="scanPhotoTableContainer" style="margin-top: 20px;">
                    <table class="data-table" id="scanPhotoTable" style="width: 100%;">
                        <thead>
                            <tr>
                                <th onclick="sortScanPhotoTable('rank')">Rank</th>
                                <th onclick="sortScanPhotoTable('name')">Category</th>
                                <th onclick="sortScanPhotoTable('total')">Total Docs</th>
                                <th onclick="sortScanPhotoTable('scans')">Scans/Photos</th>
                                <th onclick="sortScanPhotoTable('digital')">Digital</th>
                                <th onclick="sortScanPhotoTable('percentage')">Percentage</th>
                                <th>Scan/Photo Types</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${entries.map(([category, info], idx) => {
                                // Get image types for this category to identify scan/photo types
                                const imageTypes = currentData.image_types_analysis && currentData.image_types_analysis[category] ? currentData.image_types_analysis[category] : {};
                                const scanPhotoTypes = Object.entries(imageTypes)
                                    .filter(([type]) => type.toLowerCase().includes('scan') || type.toLowerCase().includes('photo') || type.toLowerCase().includes('image'))
                                    .sort((a, b) => b[1].documents_with_type - a[1].documents_with_type)
                                    .slice(0, 3)
                                    .map(([type, typeInfo]) => `${type.replace(/_/g, ' ')} (${typeInfo.documents_with_type})`)
                                    .join(', ') || 'N/A';
                                
                                return `
                                <tr>
                                    <td><strong>#${idx + 1}</strong></td>
                                    <td><strong style="color: #212529;">${escapeHtml(category)}</strong></td>
                                    <td style="color: #212529;">${info.total.toLocaleString()}</td>
                                    <td style="color: #212529;">${info.scans_or_photos.toLocaleString()}</td>
                                    <td style="color: #212529;">${(info.total - info.scans_or_photos).toLocaleString()}</td>
                                    <td>
                                        <div style="display: flex; align-items: center; gap: 10px;">
                                            <span style="min-width: 60px; color: #212529;">${info.percentage}%</span>
                                            <div class="comparison-bar">
                                                <div class="comparison-bar-fill" style="width: ${info.percentage}%; background: linear-gradient(90deg, ${getCategoryColor(category)} 0%, ${getCategoryColor(category)} 100%);"></div>
                                            </div>
                                        </div>
                                    </td>
                                    <td style="color: #212529; font-size: 13px;">${escapeHtml(scanPhotoTypes)}</td>
                                </tr>
                            `;
                            }).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            
            // Initialize sort indicators
            updateScanPhotoSortIndicators();
        }
        
        function sortScanPhotoTable(field) {
            const data = currentData.scan_photo_analysis;
            // Default sort by total docs (descending)
            let entries = Object.entries(data).sort((a, b) => b[1].total - a[1].total);
            
            // Toggle sort direction if clicking same field
            const currentSort = scanPhotoTableSort.split('-');
            if (currentSort[0] === field) {
                scanPhotoTableSort = currentSort[1] === 'desc' ? `${field}-asc` : `${field}-desc`;
            } else {
                scanPhotoTableSort = `${field}-desc`;
            }
            
            // Sort entries
            const [sortField, direction] = scanPhotoTableSort.split('-');
            entries.sort((a, b) => {
                let comparison = 0;
                if (sortField === 'rank' || sortField === 'name') {
                    comparison = a[0].localeCompare(b[0]);
                } else if (sortField === 'total') {
                    comparison = a[1].total - b[1].total;
                } else if (sortField === 'scans') {
                    comparison = a[1].scans_or_photos - b[1].scans_or_photos;
                } else if (sortField === 'digital') {
                    comparison = (a[1].total - a[1].scans_or_photos) - (b[1].total - b[1].scans_or_photos);
                } else if (sortField === 'percentage') {
                    comparison = a[1].percentage - b[1].percentage;
                }
                return direction === 'desc' ? -comparison : comparison;
            });
            
            // Update table
            const tbody = document.querySelector('#scanPhotoTable tbody');
            if (tbody) {
                tbody.innerHTML = entries.map(([category, info], idx) => {
                    // Get image types for this category to identify scan/photo types
                    const imageTypes = currentData.image_types_analysis && currentData.image_types_analysis[category] ? currentData.image_types_analysis[category] : {};
                    const scanPhotoTypes = Object.entries(imageTypes)
                        .filter(([type]) => type.toLowerCase().includes('scan') || type.toLowerCase().includes('photo') || type.toLowerCase().includes('image'))
                        .sort((a, b) => b[1].documents_with_type - a[1].documents_with_type)
                        .slice(0, 3)
                        .map(([type, typeInfo]) => `${type.replace(/_/g, ' ')} (${typeInfo.documents_with_type})`)
                        .join(', ') || 'N/A';
                    
                    return `
                    <tr>
                        <td><strong>#${idx + 1}</strong></td>
                        <td><strong style="color: #212529;">${escapeHtml(category)}</strong></td>
                        <td style="color: #212529;">${info.total.toLocaleString()}</td>
                        <td style="color: #212529;">${info.scans_or_photos.toLocaleString()}</td>
                        <td style="color: #212529;">${(info.total - info.scans_or_photos).toLocaleString()}</td>
                        <td>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span style="min-width: 60px; color: #212529;">${info.percentage}%</span>
                                <div class="comparison-bar">
                                    <div class="comparison-bar-fill" style="width: ${info.percentage}%; background: linear-gradient(90deg, ${getCategoryColor(category)} 0%, ${getCategoryColor(category)} 100%);"></div>
                                </div>
                            </div>
                        </td>
                        <td style="color: #212529; font-size: 13px;">${escapeHtml(scanPhotoTypes)}</td>
                    </tr>
                `;
                }).join('');
            }
            
            // Update sort indicators
            updateScanPhotoSortIndicators();
        }
        
        function updateScanPhotoSortIndicators() {
            document.querySelectorAll('#scanPhotoTable th').forEach(th => {
                th.classList.remove('sort-asc', 'sort-desc');
            });
            const [field, direction] = scanPhotoTableSort.split('-');
            const fieldMap = { 'rank': 0, 'name': 1, 'total': 2, 'scans': 3, 'digital': 4, 'percentage': 5 };
            const headerIndex = fieldMap[field];
            if (headerIndex !== undefined) {
                const headers = document.querySelectorAll('#scanPhotoTable th');
                if (headers[headerIndex]) {
                    headers[headerIndex].classList.add(direction === 'asc' ? 'sort-asc' : 'sort-desc');
                }
            }
        }

        function filterScanPhoto() {
            const sortBy = 'percentage-desc'; // Default sort
            const data = currentData.scan_photo_analysis;
            let entries = Object.entries(data);
            
            // Sort
            const [field, direction] = sortBy.split('-');
            entries.sort((a, b) => {
                let comparison = 0;
                if (field === 'percentage') {
                    comparison = a[1].percentage - b[1].percentage;
                } else if (field === 'count') {
                    comparison = a[1].scans_or_photos - b[1].scans_or_photos;
                } else if (field === 'name') {
                    comparison = a[0].localeCompare(b[0]);
                }
                return direction === 'desc' ? -comparison : comparison;
            });
            
            // Update display
            const container = document.getElementById('scanPhotoCards');
            container.innerHTML = entries.map(([category, info]) => `
                <div class="analysis-card" data-category="${escapeHtml(category)}">
                    <div class="analysis-card-header">
                        <div>
                            <div class="analysis-card-title">${escapeHtml(category)}</div>
                            <div style="color: #6c757d; margin-top: 5px; font-size: 0.9em;">
                                ${info.total.toLocaleString()} total documents
                            </div>
                        </div>
                        <div class="analysis-card-stats">
                            <div class="analysis-stat">
                                <span class="analysis-stat-value">${info.percentage}%</span>
                                <span class="analysis-stat-label">Scans/Photos</span>
                            </div>
                            <div class="analysis-stat">
                                <span class="analysis-stat-value">${info.scans_or_photos}</span>
                                <span class="analysis-stat-label">Documents</span>
                            </div>
                        </div>
                    </div>
                    <div class="percentage-display">
                        <div class="percentage-value">${info.percentage}%</div>
                        <div class="percentage-details">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                                <span style="color: #6c757d;">Scans/Photos: ${info.scans_or_photos.toLocaleString()}</span>
                                <span style="color: #6c757d;">Digital: ${(info.total - info.scans_or_photos).toLocaleString()}</span>
                            </div>
                            <div class="percentage-bar-large">
                                <div class="percentage-fill-large" style="width: ${info.percentage}%; background: linear-gradient(90deg, ${getCategoryColor(category)} 0%, ${getCategoryColor(category)} 100%);"></div>
                            </div>
                        </div>
                    </div>
                </div>
            `).join('');
        }

        function renderLanguagesView() {
            console.log('üîç [LANGUAGES VIEW] Rendering language view');
            console.log('üîç [LANGUAGES VIEW] Current data languages_analysis:', 
                currentData.languages_analysis ? Object.keys(currentData.languages_analysis).length + ' categories' : 'null');
            console.log('üîç [LANGUAGES VIEW] Current data level1_distribution:', 
                currentData.level1_distribution ? Object.keys(currentData.level1_distribution).length + ' categories' : 'null');
            
            // Check if languages panel is active
            const languagesPanel = document.getElementById('languages');
            if (!languagesPanel || !languagesPanel.classList.contains('active')) {
                console.log('üîç [LANGUAGES VIEW] Languages panel not active, skipping render');
                return;
            }
            
            // Check if panel structure exists, restore if missing
            if (languagesPanel && !languagesPanel.querySelector('#languagesCategorySelector')) {
                console.log('üîç [LANGUAGES VIEW] Restoring panel structure...');
                languagesPanel.innerHTML = `
                    <div class="level-selector">
                        <select id="languagesCategorySelector" class="enhanced-dropdown">
                            <option value="">All Categories</option>
                        </select>
                    </div>
                    <div class="category-list" id="languagesList"></div>
                `;
            }
            
            const selector = document.getElementById('languagesCategorySelector');
            if (!selector) {
                console.error('üîç [LANGUAGES VIEW] Selector not found after structure restoration');
                return;
            }
            
            // Store current selection before repopulating
            const currentSelection = selector.value;
            console.log('üîç [LANGUAGES VIEW] Current selection:', currentSelection);
            
            // Populate category selector with same format as Level 2 dropdown
            selector.innerHTML = '<option value="">All Categories</option>';
            
            // Get categories from languages_analysis, but use level1_distribution for counts/percentages
            const data = currentData.languages_analysis;
            if (!data || Object.keys(data).length === 0) {
                console.warn('üîç [LANGUAGES VIEW] No language data available');
                const listContainer = document.getElementById('languagesList');
                if (listContainer) {
                    listContainer.innerHTML = '<div class="empty-state">No language data available.</div>';
                }
                return;
            }
            
            // Get categories that have both language data AND are in level1_distribution (for filtered data)
            const categories = Object.entries(currentData.level1_distribution)
                .filter(([cat]) => data[cat]) // Only include categories that have language data
                .sort((a, b) => b[1].count - a[1].count); // Sort by count (most popular first)
            
            console.log('üîç [LANGUAGES VIEW] Categories with language data:', categories.length);
            console.log('üîç [LANGUAGES VIEW] Sample categories:', categories.slice(0, 5).map(([cat]) => cat));
            
            categories.forEach(([cat, info]) => {
                const option = document.createElement('option');
                option.value = cat;
                
                // Format option text with stats (same as Level 2)
                const countStr = info.count.toLocaleString();
                const pctStr = info.percentage.toFixed(2);
                const fullText = `${cat} - ${countStr} docs (${pctStr}%)`;
                
                option.textContent = fullText;
                option.setAttribute('data-full-text', fullText);
                
                // Highlight core categories (>=5% of total)
                const totalDocs = currentData.total_records;
                const coreThreshold = totalDocs * 0.05;
                if (info.count >= coreThreshold) {
                    option.className = 'category-option-core';
                }
                
                selector.appendChild(option);
            });
            
            // Restore previous selection if it still exists, otherwise use "All Categories"
            let selectedCategory = '';
            if (currentSelection) {
                // Check if the previously selected category still exists in the filtered data
                const categoryExists = categories.some(([cat]) => cat === currentSelection);
                if (categoryExists) {
                    selector.value = currentSelection;
                    selectedCategory = currentSelection;
                    // Update display text to show just category name
                    const selected = selector.options[selector.selectedIndex];
                    if (selected && selected.getAttribute('data-full-text')) {
                        const categoryName = selected.getAttribute('data-full-text').split(' - ')[0];
                        selected.textContent = categoryName;
                    }
                } else {
                    // Previous selection no longer exists, use "All Categories"
                    selector.value = '';
                    selectedCategory = '';
                }
            } else {
                // No previous selection, use "All Categories" as default
                selector.value = '';
                selectedCategory = '';
            }
            
            // Remove old listeners by removing the attribute and re-adding listeners
            if (selector.hasAttribute('data-listeners-added')) {
                selector.removeAttribute('data-listeners-added');
            }
            
            // Set the value on the selector
            if (selectedCategory) {
                selector.value = selectedCategory;
            }
            
            // Add event listeners for dropdown behavior (same as Level 2) - only once
            if (!selector.hasAttribute('data-listeners-added')) {
                selector.setAttribute('data-listeners-added', 'true');
                
                selector.addEventListener('focus', function() {
                    // When dropdown opens, show full text in options
                    Array.from(this.options).forEach(opt => {
                        if (opt.value && opt.getAttribute('data-full-text')) {
                            opt.textContent = opt.getAttribute('data-full-text');
                        }
                    });
                });
                
                selector.addEventListener('change', function() {
                    // When selection changes, update display to show just category name
                    const selected = this.options[this.selectedIndex];
                    if (selected && selected.value) {
                        const categoryName = selected.getAttribute('data-full-text')?.split(' - ')[0] || selected.textContent.split(' - ')[0];
                        selected.textContent = categoryName;
                        // Restore full text to other options
                        Array.from(this.options).forEach(opt => {
                            if (opt !== selected && opt.value && opt.getAttribute('data-full-text')) {
                                opt.textContent = opt.getAttribute('data-full-text');
                            }
                        });
                    }
                    // Re-render with selected category
                    renderLanguagesViewContent(this.value);
                });
            }
            
            // Render the content using the selector's value
            const finalSelectedCategory = selector.value || '';
            renderLanguagesViewContent(finalSelectedCategory);
        }
        
        function renderLanguagesViewContent(selectedCategory) {
            // Check if languages view is active
            const languagesPanel = document.getElementById('languages');
            if (!languagesPanel) {
                console.warn('üîç [LANGUAGES CONTENT] Languages panel not found');
                return;
            }
            
            const data = currentData.languages_analysis;
            
            const listContainer = document.getElementById('languagesList');
            if (!listContainer) {
                console.warn('üîç [LANGUAGES CONTENT] List container not found');
                return;
            }
            
            // If "All Categories" is selected, aggregate data across all categories
            if (!selectedCategory) {
                // Filter out categories with empty language objects
                const categoriesWithLanguages = Object.keys(data).filter(cat => {
                    const langData = data[cat];
                    return langData && typeof langData === 'object' && !Array.isArray(langData) && Object.keys(langData).length > 0;
                });
                
                if (categoriesWithLanguages.length === 0) {
                    console.warn('üîç [LANGUAGES CONTENT] No categories with language data found');
                    listContainer.innerHTML = '<div class="empty-state">No language data available for the selected filters.</div>';
                    return;
                }
                
                // Aggregate languages across all categories
                const aggregatedLanguages = {};
                const categoryDocCounts = {}; // Track unique documents per category to avoid double counting
                
                const allCategories = categoriesWithLanguages;
                
                allCategories.forEach(category => {
                    const languages = data[category];
                    console.log(`üîç [LANGUAGES CONTENT] Processing category "${category}":`, languages);
                    
                    if (!languages || typeof languages !== 'object') {
                        console.warn(`üîç [LANGUAGES CONTENT] Invalid language data for category "${category}"`);
                        return;
                    }
                    
                    // Get total documents for this category from level1_distribution
                    const categoryTotal = currentData.level1_distribution[category]?.count || 0;
                    categoryDocCounts[category] = categoryTotal;
                    
                    const langEntries = Object.entries(languages);
                    
                    langEntries.forEach(([lang, info]) => {
                        // Skip internal properties like _docsWithImages
                        if (lang.startsWith('_')) {
                            return;
                        }
                        
                        if (!info || typeof info !== 'object') {
                            return;
                        }
                        
                        const langCount = info.count || 0;
                        
                        if (langCount > 0) {
                            if (!aggregatedLanguages[lang]) {
                                aggregatedLanguages[lang] = { count: 0 };
                            }
                            aggregatedLanguages[lang].count += langCount;
                        }
                    });
                });
                
                // Calculate total unique documents (sum of category totals)
                const totalDocs = Object.values(categoryDocCounts).reduce((sum, count) => sum + count, 0);
                
                // Calculate percentages based on total documents
                Object.keys(aggregatedLanguages).forEach(lang => {
                    aggregatedLanguages[lang].percentage = totalDocs > 0 ? 
                        round((aggregatedLanguages[lang].count / totalDocs) * 100, 2) : 0;
                });
                
                // Convert to entries and sort by count
                const langEntries = Object.entries(aggregatedLanguages).sort((a, b) => b[1].count - a[1].count);
                
                if (langEntries.length === 0) {
                    listContainer.innerHTML = '<div class="empty-state">No language data available.</div>';
                    return;
                }
                listContainer.innerHTML = `
                    <div class="analysis-summary">
                        <h2>üåê Language Distribution: All Categories</h2>
                        <div class="summary-metrics">
                            <div class="summary-metric">
                                <div class="summary-metric-label">Total Documents</div>
                                <div class="summary-metric-value">${totalDocs.toLocaleString()}</div>
                            </div>
                            <div class="summary-metric">
                                <div class="summary-metric-label">Languages Detected</div>
                                <div class="summary-metric-value">${langEntries.length}</div>
                            </div>
                            <div class="summary-metric">
                                <div class="summary-metric-label">Most Common</div>
                                <div class="summary-metric-value" style="font-size: 1.2em;">${langEntries.length > 0 ? escapeHtml(langEntries[0][0]) : 'N/A'}</div>
                            </div>
                        </div>
                    </div>
                    
                    <div id="languagesTableContainer" style="margin-top: 20px;">
                        <table class="data-table" id="languagesTable" style="width: 100%;">
                            <thead>
                                <tr>
                                    <th>Rank</th>
                                    <th>Language</th>
                                    <th>Count</th>
                                    <th>Percentage</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${langEntries.map(([lang, info], idx) => `
                                    <tr>
                                        <td><strong>#${idx + 1}</strong></td>
                                        <td><strong style="color: #212529;">${escapeHtml(lang)}</strong></td>
                                        <td style="color: #212529;">${info.count.toLocaleString()}</td>
                                        <td>
                                            <div style="display: flex; align-items: center; gap: 10px;">
                                                <span style="min-width: 60px; color: #212529;">${info.percentage}%</span>
                                                <div class="comparison-bar">
                                                    <div class="comparison-bar-fill" style="width: ${info.percentage}%; background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);"></div>
                                                </div>
                                            </div>
                                        </td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
                console.log('üîç [LANGUAGES CONTENT] HTML set, innerHTML length:', listContainer.innerHTML.length);
                console.log('üîç [LANGUAGES CONTENT] First 200 chars:', listContainer.innerHTML.substring(0, 200));
                return;
            }
            
            // Get language data for selected category
            const languages = data[selectedCategory];
            
            if (!languages || Object.keys(languages).length === 0) {
                listContainer.innerHTML = `
                    <div class="empty-state">
                        <p>No language data available for "${escapeHtml(selectedCategory)}".</p>
                    </div>
                `;
                return;
            }
            
            // Convert to entries and sort by count
            const langEntries = Object.entries(languages).sort((a, b) => b[1].count - a[1].count);
            const totalDocs = Object.values(languages).reduce((sum, v) => sum + v.count, 0);
            
            listContainer.innerHTML = `
                <div class="analysis-summary">
                    <h2>üåê Language Distribution: ${escapeHtml(selectedCategory)}</h2>
                    <div class="summary-metrics">
                        <div class="summary-metric">
                            <div class="summary-metric-label">Total Documents</div>
                            <div class="summary-metric-value">${totalDocs.toLocaleString()}</div>
                        </div>
                        <div class="summary-metric">
                            <div class="summary-metric-label">Languages Detected</div>
                            <div class="summary-metric-value">${langEntries.length}</div>
                        </div>
                        <div class="summary-metric">
                            <div class="summary-metric-label">Most Common</div>
                            <div class="summary-metric-value" style="font-size: 1.2em;">${langEntries.length > 0 ? escapeHtml(langEntries[0][0]) : 'N/A'}</div>
                        </div>
                    </div>
                </div>
                
                <div id="languagesTableContainer" style="margin-top: 20px;">
                    <table class="data-table" id="languagesTable" style="width: 100%;">
                        <thead>
                            <tr>
                                <th>Rank</th>
                                <th>Language</th>
                                <th>Count</th>
                                <th>Percentage</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${langEntries.map(([lang, info], idx) => `
                                <tr>
                                    <td><strong>#${idx + 1}</strong></td>
                                    <td><strong style="color: #212529;">${escapeHtml(lang)}</strong></td>
                                    <td style="color: #212529;">${info.count.toLocaleString()}</td>
                                    <td>
                                        <div style="display: flex; align-items: center; gap: 10px;">
                                            <span style="min-width: 60px; color: #212529;">${info.percentage}%</span>
                                            <div class="comparison-bar">
                                                <div class="comparison-bar-fill" style="width: ${info.percentage}%; background: linear-gradient(90deg, ${getCategoryColor(selectedCategory)} 0%, ${getCategoryColor(selectedCategory)} 100%);"></div>
                                            </div>
                                        </div>
                                    </td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            
            console.log('üîç [LANGUAGES CONTENT] HTML content length:', htmlContent.length);
            listContainer.innerHTML = htmlContent;
            console.log('üîç [LANGUAGES CONTENT] innerHTML set, container children:', listContainer.children.length);
        }

        function filterLanguages() {
            const filter = document.getElementById('languagesFilter').value.toLowerCase();
            const data = currentData.languages_analysis;
            let entries = Object.entries(data);
            
            if (filter) {
                entries = entries.filter(([cat]) => cat.toLowerCase().includes(filter));
            }
            
            // Re-render with filtered data
            const container = document.getElementById('languagesCards');
            container.innerHTML = entries.map(([category, languages]) => {
                const langEntries = Object.entries(languages).sort((a, b) => b[1].count - a[1].count);
                const totalLangs = langEntries.length;
                const topLang = langEntries[0];
                
                return `
                    <div class="analysis-card" data-category="${escapeHtml(category)}">
                        <div class="analysis-card-header">
                            <div>
                                <div class="analysis-card-title">${escapeHtml(category)}</div>
                                <div style="color: #6c757d; margin-top: 5px; font-size: 0.9em;">
                                    ${totalLangs} language${totalLangs !== 1 ? 's' : ''} detected
                                </div>
                            </div>
                            ${topLang ? `
                                <div class="analysis-card-stats">
                                    <div class="analysis-stat">
                                        <span class="analysis-stat-value" style="font-size: 1.2em;">${escapeHtml(topLang[0])}</span>
                                        <span class="analysis-stat-label">Most Common</span>
                                    </div>
                                    <div class="analysis-stat">
                                        <span class="analysis-stat-value">${topLang[1].percentage}%</span>
                                        <span class="analysis-stat-label">Top Language</span>
                                    </div>
                                </div>
                            ` : ''}
                        </div>
                        <div style="margin-top: 20px;">
                            <table class="data-table">
                                <thead>
                                    <tr>
                                        <th>Language</th>
                                        <th>Count</th>
                                        <th>Percentage</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${langEntries.map(([lang, info]) => `
                                        <tr>
                                            <td><strong>${escapeHtml(lang)}</strong></td>
                                            <td>${info.count.toLocaleString()}</td>
                                            <td>
                                                <div style="display: flex; align-items: center; gap: 10px;">
                                                    <span>${info.percentage}%</span>
                                                    <div style="flex: 1; height: 8px; background: #e9ecef; border-radius: 4px; max-width: 150px;">
                                                        <div class="percentage-fill" style="width: ${info.percentage}%"></div>
                                                    </div>
                                                </div>
                                            </td>
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function renderPersonalDataView() {
            const data = currentData.personal_data_analysis;
            // Sort by total docs (descending) - most popular first
            const entries = Object.entries(data).sort((a, b) => b[1].total - a[1].total);
            
            // Calculate summary
            const totalDocs = Object.values(data).reduce((sum, d) => sum + d.total, 0);
            const totalWithPersonal = Object.values(data).reduce((sum, d) => sum + d.with_personal_data, 0);
            const avgPercentage = Object.values(data).reduce((sum, d) => sum + d.percentage, 0) / entries.length;
            const highRiskCategories = entries.filter(([, d]) => d.percentage >= 50).length;
            const mediumRiskCategories = entries.filter(([, d]) => d.percentage >= 25 && d.percentage < 50).length;
            const lowRiskCategories = entries.filter(([, d]) => d.percentage < 25).length;
            const top5HighRisk = entries.filter(([, d]) => d.percentage >= 50).slice(0, 5);
            
            const listContainer = document.getElementById('personalDataList');
            listContainer.innerHTML = `
                <div class="analysis-summary">
                    <h2>üîí Personal Data Analysis</h2>
                    <div class="summary-metrics">
                        <div class="summary-metric">
                            <div class="summary-metric-label">Total Documents</div>
                            <div class="summary-metric-value">${totalDocs.toLocaleString()}</div>
                        </div>
                        <div class="summary-metric">
                            <div class="summary-metric-label">With Personal Data</div>
                            <div class="summary-metric-value">${totalWithPersonal.toLocaleString()}</div>
                        </div>
                        <div class="summary-metric">
                            <div class="summary-metric-label">Average Percentage</div>
                            <div class="summary-metric-value">${avgPercentage.toFixed(1)}%</div>
                        </div>
                        <div class="summary-metric">
                            <div class="summary-metric-label">Categories (‚â•50%)</div>
                            <div class="summary-metric-value">${highRiskCategories}</div>
                        </div>
                    </div>
                </div>
                
                <div id="personalDataTableContainer" style="margin-top: 20px;">
                    <table class="data-table" id="personalDataTable" style="width: 100%;">
                        <thead>
                            <tr>
                                <th onclick="sortPersonalDataTable('rank')">Rank</th>
                                <th onclick="sortPersonalDataTable('name')">Category</th>
                                <th onclick="sortPersonalDataTable('total')">Total Docs</th>
                                <th onclick="sortPersonalDataTable('with')">With Personal Data</th>
                                <th onclick="sortPersonalDataTable('percentage')">Percentage</th>
                                <th>Personal Data Types</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${entries.map(([category, info], idx) => {
                                // Get image types for this category to identify personal data types
                                const imageTypes = currentData.image_types_analysis && currentData.image_types_analysis[category] ? currentData.image_types_analysis[category] : {};
                                const personalDataTypes = Object.entries(imageTypes)
                                    .filter(([type]) => {
                                        const typeLower = type.toLowerCase();
                                        return typeLower.includes('personal') || typeLower.includes('data') || 
                                               typeLower.includes('id') || typeLower.includes('identity') ||
                                               typeLower.includes('name') || typeLower.includes('address') ||
                                               typeLower.includes('phone') || typeLower.includes('email') ||
                                               typeLower.includes('ssn') || typeLower.includes('passport') ||
                                               typeLower.includes('license') || typeLower.includes('credit');
                                    })
                                    .sort((a, b) => b[1].documents_with_type - a[1].documents_with_type)
                                    .slice(0, 3)
                                    .map(([type, typeInfo]) => `${type.replace(/_/g, ' ')} (${typeInfo.documents_with_type})`)
                                    .join(', ') || 'N/A';
                                
                                return `
                                <tr>
                                    <td><strong>#${idx + 1}</strong></td>
                                    <td><strong style="color: #212529;">${escapeHtml(category)}</strong></td>
                                    <td style="color: #212529;">${info.total.toLocaleString()}</td>
                                    <td style="color: #212529;">${info.with_personal_data.toLocaleString()}</td>
                                    <td>
                                        <div style="display: flex; align-items: center; gap: 10px;">
                                            <span style="min-width: 60px; color: #212529;">${info.percentage}%</span>
                                            <div class="comparison-bar">
                                                <div class="comparison-bar-fill" style="width: ${info.percentage}%; background: linear-gradient(90deg, ${getCategoryColor(category)} 0%, ${getCategoryColor(category)} 100%);"></div>
                                            </div>
                                        </div>
                                    </td>
                                    <td style="color: #212529; font-size: 13px;">${escapeHtml(personalDataTypes)}</td>
                                </tr>
                            `;
                            }).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            
            // Initialize sort indicators
            updatePersonalDataSortIndicators();
        }
        
        function updatePersonalDataSortIndicators() {
            document.querySelectorAll('#personalDataTable th').forEach(th => {
                th.classList.remove('sort-asc', 'sort-desc');
            });
            const [field, direction] = personalDataTableSort.split('-');
            const fieldMap = { 'rank': 0, 'name': 1, 'total': 2, 'with': 3, 'percentage': 4 };
            const headerIndex = fieldMap[field];
            if (headerIndex !== undefined) {
                const headers = document.querySelectorAll('#personalDataTable th');
                if (headers[headerIndex]) {
                    headers[headerIndex].classList.add(direction === 'asc' ? 'sort-asc' : 'sort-desc');
                }
            }
        }
        

        function filterPersonalData() {
            const sortBy = 'percentage-desc'; // Default sort
            const data = currentData.personal_data_analysis;
            let entries = Object.entries(data);
            
            // Sort
            const [field, direction] = sortBy.split('-');
            entries.sort((a, b) => {
                let comparison = 0;
                if (field === 'percentage') {
                    comparison = a[1].percentage - b[1].percentage;
                } else if (field === 'count') {
                    comparison = a[1].with_personal_data - b[1].with_personal_data;
                } else if (field === 'name') {
                    comparison = a[0].localeCompare(b[0]);
                }
                return direction === 'desc' ? -comparison : comparison;
            });
            
            // Update display
            const container = document.getElementById('personalDataCards');
            container.innerHTML = entries.map(([category, info]) => `
                <div class="analysis-card" data-category="${escapeHtml(category)}">
                    <div class="analysis-card-header">
                        <div>
                            <div class="analysis-card-title">${escapeHtml(category)}</div>
                            <div style="color: #6c757d; margin-top: 5px; font-size: 0.9em;">
                                ${info.total.toLocaleString()} total documents
                            </div>
                        </div>
                        <div class="analysis-card-stats">
                            <div class="analysis-stat">
                                <span class="analysis-stat-value" style="color: ${info.percentage >= 50 ? '#e74c3c' : info.percentage >= 25 ? '#f39c12' : '#667eea'};">${info.percentage}%</span>
                                <span class="analysis-stat-label">Personal Data</span>
                            </div>
                            <div class="analysis-stat">
                                <span class="analysis-stat-value">${info.with_personal_data}</span>
                                <span class="analysis-stat-label">Documents</span>
                            </div>
                        </div>
                    </div>
                    <div class="percentage-display">
                        <div class="percentage-value" style="color: ${info.percentage >= 50 ? '#e74c3c' : info.percentage >= 25 ? '#f39c12' : '#667eea'};">
                            ${info.percentage}%
                        </div>
                        <div class="percentage-details">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                                <span style="color: #6c757d;">With personal data: ${info.with_personal_data.toLocaleString()}</span>
                                <span style="color: #6c757d;">Without: ${(info.total - info.with_personal_data).toLocaleString()}</span>
                            </div>
                            <div class="percentage-bar-large">
                                <div class="percentage-fill-large" style="width: ${info.percentage}%; background: linear-gradient(90deg, ${getCategoryColor(category)} 0%, ${getCategoryColor(category)} 100%);"></div>
                            </div>
                            ${info.percentage >= 50 ? '<div style="margin-top: 8px; color: #e74c3c; font-size: 0.85em; font-weight: 600;">‚ö†Ô∏è High Risk Category</div>' : ''}
                        </div>
                    </div>
                </div>
            `).join('');
        }

        function renderPieChart(canvasId, data, tooltipCallback, tooltipId = 'tooltip', providedColors = null) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;

            const container = canvas.parentElement;
            // Make chart bigger - use more of the available space
            const maxSize = Math.min(container.clientWidth - 40, container.clientHeight - 40, 700);
            const size = Math.max(maxSize, 500); // Minimum 500px, up to 700px
            canvas.width = size;
            canvas.height = size;
            canvas.style.width = size + 'px';
            canvas.style.height = size + 'px';

            const ctx = canvas.getContext('2d');
            const centerX = size / 2;
            const centerY = size / 2;
            const radius = (size / 2) - 20;

            const total = data.reduce((sum, [, info]) => sum + info.count, 0);
            const colors = providedColors || generateColors(data.length);

            let currentAngle = -Math.PI / 2;
            const segments = [];

            ctx.clearRect(0, 0, size, size);

            data.forEach(([category, info], index) => {
                const angle = (info.count / total) * 2 * Math.PI;
                const startAngle = currentAngle;
                const endAngle = currentAngle + angle;

                segments.push({ category, info, startAngle, endAngle, color: colors[index], index });

                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                ctx.closePath();
                ctx.fillStyle = colors[index];
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                currentAngle = endAngle;
            });

            canvas.segments = segments;

            // Store original segments and colors for redrawing
            canvas.originalSegments = segments;
            canvas.originalColors = colors;
            canvas.centerX = centerX;
            canvas.centerY = centerY;
            canvas.radius = radius;

            canvas.onmousemove = function(e) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;

                const dx = x - centerX;
                const dy = y - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < radius) {
                    const angle = Math.atan2(dy, dx);
                    let normalizedAngle = angle;
                    if (normalizedAngle < -Math.PI / 2) normalizedAngle += 2 * Math.PI;
                    normalizedAngle += Math.PI / 2;

                    const hovered = segments.find(seg => {
                        let segStart = seg.startAngle;
                        let segEnd = seg.endAngle;
                        if (segStart < -Math.PI / 2) segStart += 2 * Math.PI;
                        if (segEnd < -Math.PI / 2) segEnd += 2 * Math.PI;
                        segStart += Math.PI / 2;
                        segEnd += Math.PI / 2;
                        return normalizedAngle >= segStart && normalizedAngle <= segEnd;
                    });

                    if (hovered && hovered !== hoveredSegment) {
                        // Redraw chart with highlighted segment
                        redrawChartWithHighlight(canvas, ctx, segments, colors, hovered, centerX, centerY, radius);
                        
                        hoveredSegment = hovered;
                        const tooltip = document.getElementById(tooltipId);
                        tooltip.innerHTML = tooltipCallback(hovered);
                        tooltip.style.display = 'block';
                        canvas.style.cursor = 'pointer';
                        updateTooltipPosition(e, tooltip);
                    } else if (!hovered && hoveredSegment) {
                        // Redraw chart without highlight
                        redrawChart(canvas, ctx, segments, colors, centerX, centerY, radius);
                        hoveredSegment = null;
                        document.getElementById(tooltipId).style.display = 'none';
                        canvas.style.cursor = 'default';
                    }
                } else {
                    if (hoveredSegment) {
                        redrawChart(canvas, ctx, segments, colors, centerX, centerY, radius);
                        document.getElementById(tooltipId).style.display = 'none';
                        hoveredSegment = null;
                        canvas.style.cursor = 'default';
                    }
                }
            };

            canvas.onmouseleave = function() {
                if (hoveredSegment) {
                    redrawChart(canvas, ctx, segments, colors, centerX, centerY, radius);
                }
                document.getElementById(tooltipId).style.display = 'none';
                hoveredSegment = null;
                canvas.style.cursor = 'default';
            };
        }

        function redrawChart(canvas, ctx, segments, colors, centerX, centerY, radius) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            segments.forEach((seg, index) => {
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, radius, seg.startAngle, seg.endAngle);
                ctx.closePath();
                ctx.fillStyle = colors[index];
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }

        function redrawChartWithHighlight(canvas, ctx, segments, colors, highlightedSeg, centerX, centerY, radius) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            segments.forEach((seg, index) => {
                const isHighlighted = seg === highlightedSeg;
                const highlightRadius = isHighlighted ? radius + 8 : radius;
                const highlightLineWidth = isHighlighted ? 4 : 2;
                
                // Make highlighted segment brighter
                let fillColor = colors[index];
                if (isHighlighted) {
                    // Increase brightness by adjusting opacity or using a lighter version
                    if (fillColor.startsWith('hsl') || fillColor.startsWith('hsla')) {
                        fillColor = fillColor.replace(/,\s*\d+%\)/, ', 70%)');
                    } else if (fillColor.startsWith('#')) {
                        // Convert hex to RGB and lighten
                        const rgb = hexToRgb(fillColor);
                        if (rgb) {
                            fillColor = `rgba(${Math.min(255, rgb.r + 30)}, ${Math.min(255, rgb.g + 30)}, ${Math.min(255, rgb.b + 30)}, 1)`;
                        }
                    }
                }
                
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, highlightRadius, seg.startAngle, seg.endAngle);
                ctx.closePath();
                ctx.fillStyle = fillColor;
                ctx.fill();
                ctx.strokeStyle = isHighlighted ? '#fff' : '#fff';
                ctx.lineWidth = highlightLineWidth;
                ctx.stroke();
            });
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function updateTooltipPosition(event, tooltip) {
            // Wait for tooltip to be rendered to get accurate dimensions
            tooltip.style.visibility = 'hidden';
            tooltip.style.display = 'block';
            
            const tooltipWidth = tooltip.offsetWidth;
            const tooltipHeight = tooltip.offsetHeight;
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            const scrollX = window.pageXOffset || document.documentElement.scrollLeft;
            const scrollY = window.pageYOffset || document.documentElement.scrollTop;
            
            const padding = 15;
            const mouseX = event.clientX + scrollX;
            const mouseY = event.clientY + scrollY;

            // Calculate position relative to viewport
            let left = event.clientX + padding;
            let top = event.clientY + padding;

            // Adjust horizontally if tooltip would go off screen
            if (left + tooltipWidth > windowWidth - padding) {
                // Try left side of cursor
                left = event.clientX - tooltipWidth - padding;
                // If still off screen, align to right edge
                if (left < padding) {
                    left = windowWidth - tooltipWidth - padding;
                }
            }

            // Adjust vertically if tooltip would go off screen
            if (top + tooltipHeight > windowHeight - padding) {
                // Try above cursor
                top = event.clientY - tooltipHeight - padding;
                // If still off screen, align to bottom edge
                if (top < padding) {
                    top = windowHeight - tooltipHeight - padding;
                }
            }

            // Ensure tooltip stays within viewport bounds
            left = Math.max(padding, Math.min(left, windowWidth - tooltipWidth - padding));
            top = Math.max(padding, Math.min(top, windowHeight - tooltipHeight - padding));

            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
            tooltip.style.visibility = 'visible';
        }

        function generateColors(count) {
            const colors = [];
            // Bright, vibrant color palette - ordered from most vibrant to less vibrant
            const baseColors = [
                '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8',
                '#F7DC6F', '#BB8FCE', '#85C1E2', '#F8B739', '#52BE80',
                '#EC7063', '#5DADE2', '#F4D03F', '#AF7AC5', '#76D7C4',
                '#F1948A', '#85C1E9', '#F7DC6F', '#BB8FCE', '#85C1E2',
                '#E74C3C', '#3498DB', '#2ECC71', '#F39C12', '#9B59B6',
                '#1ABC9C', '#E67E22', '#34495E', '#E91E63', '#00BCD4',
                '#FF5722', '#009688', '#795548', '#607D8B', '#FF9800'
            ];
            
            // Use base colors first, then generate variations
            for (let i = 0; i < count; i++) {
                if (i < baseColors.length) {
                    colors.push(baseColors[i]);
                } else {
                    // Generate additional bright colors with high saturation
                    const hue = ((i * 137.508) % 360); // Golden angle for better distribution
                    const saturation = 75 + (i % 2) * 10; // High saturation: 75-85%
                    const lightness = 50 + (i % 3) * 5; // Medium-high lightness: 50-60%
                    colors.push(`hsl(${hue}, ${saturation}%, ${lightness}%)`);
                }
            }
            return colors;
        }
        
        function getCategoryColor(categoryName) {
            // Return the color for a category from the global map
            // Colors are assigned based on popularity when categories are first encountered
            if (categoryColorMap[categoryName]) {
                return categoryColorMap[categoryName];
            }
            
            // If category not yet in map, assign a default bright color
            // This should rarely happen as categories should be mapped during Level 1 rendering
            const defaultColors = [
                '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8',
                '#F7DC6F', '#BB8FCE', '#85C1E2', '#F8B739', '#52BE80'
            ];
            const hash = categoryName.split('').reduce((acc, char) => {
                return char.charCodeAt(0) + ((acc << 5) - acc);
            }, 0);
            const color = defaultColors[Math.abs(hash) % defaultColors.length];
            categoryColorMap[categoryName] = color;
            return color;
        }
        
        function assignColorsByPopularity(entries) {
            // If color map hasn't been initialized yet, initialize it based on popularity
            if (!colorMapInitialized) {
                // Sort entries by popularity (count) descending
                const sortedEntries = [...entries].sort((a, b) => b[1].count - a[1].count);
                
                // Generate bright, vibrant colors
                const colors = generateColors(sortedEntries.length);
                
                // Assign colors based on popularity rank (most popular = brightest colors)
                sortedEntries.forEach(([category, info], index) => {
                    categoryColorMap[category] = colors[index];
                });
                
                colorMapInitialized = true;
            }
            
            // Return colors array in the same order as original entries
            return entries.map(([category]) => getCategoryColor(category));
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function showDetailedStats(categoryName) {
            if (!currentData) return;
            
            const modal = document.getElementById('detailedStatsModal');
            const content = document.getElementById('detailedStatsContent');
            const title = document.getElementById('modalCategoryName');
            
            title.textContent = categoryName;
            
            const level1Data = currentData.level1_distribution[categoryName] || {};
            const handwritten = currentData.handwritten_analysis[categoryName] || {};
            const scanPhoto = currentData.scan_photo_analysis[categoryName] || {};
            const personalData = currentData.personal_data_analysis[categoryName] || {};
            const languages = currentData.languages_analysis[categoryName] || {};
            const imageTypes = currentData.image_types_analysis[categoryName] || {};
            const level2Data = currentData.level2_by_level1[categoryName] || {};
            
            const level2Entries = Object.entries(level2Data).sort((a, b) => b[1].count - a[1].count);
            const imageTypesEntries = Object.entries(imageTypes).sort((a, b) => b[1].documents_with_type - a[1].documents_with_type);
            const languagesEntries = Object.entries(languages).sort((a, b) => b[1].count - a[1].count);
            
            content.innerHTML = `
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-card-label">Total Records</div>
                        <div class="stat-card-value">${level1Data.count.toLocaleString()}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-card-label">Percentage of Total</div>
                        <div class="stat-card-value">${level1Data.percentage}%</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-card-label">Handwritten Text</div>
                        <div class="stat-card-value">${handwritten.percentage || 0}%</div>
                        <div style="font-size: 0.85em; color: #6c757d; margin-top: 5px;">
                            ${handwritten.with_handwritten || 0} of ${handwritten.total || 0} documents
                        </div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-card-label">Personal Data</div>
                        <div class="stat-card-value">${personalData.percentage || 0}%</div>
                        <div style="font-size: 0.85em; color: #6c757d; margin-top: 5px;">
                            ${personalData.with_personal_data || 0} of ${personalData.total || 0} documents
                        </div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-card-label">Scans/Photos</div>
                        <div class="stat-card-value">${scanPhoto.percentage || 0}%</div>
                        <div style="font-size: 0.85em; color: #6c757d; margin-top: 5px;">
                            ${scanPhoto.scans_or_photos || 0} of ${scanPhoto.total || 0} documents
                        </div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-card-label">Level 2 Categories</div>
                        <div class="stat-card-value">${Object.keys(level2Data).length}</div>
                    </div>
                </div>

                <div class="detailed-section">
                    <h3>Level 2 Categories Distribution</h3>
                    <div class="category-list">
                        ${level2Entries.slice(0, 20).map(([cat, info]) => `
                            <div class="category-card">
                                <div class="category-header">
                                    <div class="category-name">${escapeHtml(cat)}</div>
                                    <div class="category-count">${info.count.toLocaleString()}</div>
                                </div>
                                <div class="metric-row">
                                    <span class="metric-label">Percentage:</span>
                                    <span class="metric-value">${info.percentage}%</span>
                                </div>
                                <div class="progress-bar">
                                    <div class="progress-fill" style="width: ${info.percentage}%"></div>
                                </div>
                            </div>
                        `).join('')}
                        ${level2Entries.length > 20 ? `<div style="text-align: center; padding: 20px; color: #6c757d;">+${level2Entries.length - 20} more categories</div>` : ''}
                    </div>
                </div>

                ${imageTypesEntries.length > 0 ? `
                <div class="detailed-section">
                    <h3>Image Types (Top 20)</h3>
                    <div class="image-types-grid">
                        ${imageTypesEntries.slice(0, 20).map(([typeName, info]) => `
                            <div class="image-type-card">
                                <div class="image-type-name">${escapeHtml(typeName.replace(/_/g, ' '))}</div>
                                <div class="metric-row">
                                    <span class="metric-label">Documents:</span>
                                    <span class="metric-value">${info.documents_with_type}</span>
                                </div>
                                <div class="metric-row">
                                    <span class="metric-label">Percentage:</span>
                                    <span class="metric-value">${info.percentage_of_docs}%</span>
                                </div>
                                <div class="progress-bar">
                                    <div class="progress-fill" style="width: ${info.percentage_of_docs}%"></div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
                ` : ''}

                ${languagesEntries.length > 0 ? `
                <div class="detailed-section">
                    <h3>Language Distribution</h3>
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>Language</th>
                                <th>Count</th>
                                <th>Percentage</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${languagesEntries.map(([lang, info]) => `
                                <tr>
                                    <td>${escapeHtml(lang)}</td>
                                    <td>${info.count.toLocaleString()}</td>
                                    <td>${info.percentage}%</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
                ` : ''}
            `;
            
            modal.classList.add('active');
        }

        function closeDetailedStats() {
            document.getElementById('detailedStatsModal').classList.remove('active');
        }

        // Close modal on overlay click
        // Load extension data for all products on page load
        document.addEventListener('DOMContentLoaded', async () => {
            // Ensure filters bar is visible on page load
            const filtersBar = document.getElementById('filtersBar');
            if (filtersBar) {
                filtersBar.style.display = 'flex';
            }
            
            await loadAllProductsExtensionData();
            const modal = document.getElementById('detailedStatsModal');
            if (modal) {
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        closeDetailedStats();
                    }
                });
            }
            
            // Close on Escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    closeDetailedStats();
                }
            });
        });

        // Password protection
        // IMPORTANT: Change this password hash to your desired password!
        // Default password is "password" - CHANGE THIS IMMEDIATELY!
        // 
        // To generate a new password hash:
        // 1. Open browser console (F12)
        // 2. Run: await crypto.subtle.digest('SHA-256', new TextEncoder().encode('YOUR_PASSWORD')).then(h => Array.from(new Uint8Array(h)).map(b => b.toString(16).padStart(2, '0')).join(''))
        // 3. Copy the result and replace the hash below
        // 
        // Or use online tool: https://emn178.github.io/online-tools/sha256.html
        const CORRECT_PASSWORD_HASH = '5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8'; // SHA-256 hash of "password"
        
        function hashPassword(password) {
            // Simple SHA-256 hash (async)
            return crypto.subtle.digest('SHA-256', new TextEncoder().encode(password))
                .then(hashBuffer => {
                    const hashArray = Array.from(new Uint8Array(hashBuffer));
                    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                });
        }

        function checkAuth() {
            const authToken = sessionStorage.getItem('analyzer_auth');
            const authTime = sessionStorage.getItem('analyzer_auth_time');
            const now = Date.now();
            
            // Check if authenticated and session is valid (24 hours)
            if (authToken === 'authenticated' && authTime && (now - parseInt(authTime)) < 24 * 60 * 60 * 1000) {
                return true;
            }
            return false;
        }

        function setAuth() {
            sessionStorage.setItem('analyzer_auth', 'authenticated');
            sessionStorage.setItem('analyzer_auth_time', Date.now().toString());
        }

        function showApp() {
            document.getElementById('loginScreen').classList.add('hidden');
            document.getElementById('mainApp').classList.add('authenticated');
        }

        function hideApp() {
            document.getElementById('loginScreen').classList.remove('hidden');
            document.getElementById('mainApp').classList.remove('authenticated');
        }

        // Check authentication on page load
        if (checkAuth()) {
            showApp();
        } else {
            hideApp();
        }

        // Login button handler
        document.getElementById('loginButton').addEventListener('click', async function() {
            const passwordInput = document.getElementById('passwordInput');
            const errorDiv = document.getElementById('loginError');
            const password = passwordInput.value;
            
            errorDiv.textContent = '';
            
            if (!password) {
                errorDiv.textContent = 'Please enter a password';
                return;
            }

            // Show loading state
            this.textContent = 'Checking...';
            this.disabled = true;

            try {
                const hash = await hashPassword(password);
                if (hash === CORRECT_PASSWORD_HASH) {
                    setAuth();
                    showApp();
                    // Trigger app initialization by reloading
                    location.reload();
                } else {
                    errorDiv.textContent = 'Incorrect password. Please try again.';
                    passwordInput.value = '';
                    passwordInput.focus();
                }
            } catch (error) {
                errorDiv.textContent = 'Error during authentication. Please try again.';
                console.error('Auth error:', error);
            } finally {
                this.textContent = 'Login';
                this.disabled = false;
            }
        });

        // Allow Enter key to submit
        document.getElementById('passwordInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                document.getElementById('loginButton').click();
            }
        });

        // Focus password input on load
        window.addEventListener('load', function() {
            if (!checkAuth()) {
                document.getElementById('passwordInput').focus();
            }
        });

        // Initialize
        (async function init() {
            // Don't initialize if not authenticated
            if (!checkAuth()) {
                return;
            }
            
            try {
                console.log('Initializing Multi-Product Analyzer...');
                
                // Load saved state
                const savedState = loadSavedState();
                if (savedState) {
                    console.log('Loading saved state:', savedState);
                    currentProduct = savedState.currentProduct || currentProduct;
                    currentView = savedState.currentView || currentView;
                    activeFilters = savedState.activeFilters || activeFilters;
                    level1TableView = savedState.level1TableView || level1TableView;
                    level1TableSort = savedState.level1TableSort || level1TableSort;
                }
                
                const index = await loadProductsIndex();
                console.log('Available products:', index.products);
                
                // Set active product button
                const productBtn = document.querySelector(`[data-product="${currentProduct}"]`);
                if (productBtn) {
                    productBtn.classList.add('active');
                }
                
                // Load product data
                showLoader(`Loading ${currentProduct}...`, 'Initializing...');
                try {
                    await loadProductData(currentProduct);
                } finally {
                    hideLoader();
                }
                
                // Initialize date filter mode to 'last' (UI only, filter not active by default)
                // Do this after DOM is ready and data is loaded
                setTimeout(() => {
                    try {
                        if (typeof setDateFilterMode === 'function') {
                            setDateFilterMode('last');
                        }
                    } catch (e) {
                        console.warn('Could not initialize date filter mode:', e);
                    }
                }, 100);
                
                // Restore view
                const viewBtn = document.querySelector(`[data-view="${currentView}"]`);
                if (viewBtn) {
                    document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
                    document.querySelectorAll('.view-panel').forEach(p => p.classList.remove('active'));
                    viewBtn.classList.add('active');
                    
                    // Activate the corresponding view panel (parent panel, not child)
                    let viewPanel = null;
                    if (currentView === 'level1') {
                        viewPanel = document.getElementById('level1');
                    } else if (currentView === 'level2') {
                        viewPanel = document.getElementById('level2');
                    } else {
                        viewPanel = document.getElementById(currentView);
                    }
                    
                    if (viewPanel) {
                        viewPanel.classList.add('active');
                    }
                }
                
                // Ensure view is rendered after restoring state
                if (currentData) {
                    updateView();
                }
                
                // Restore level 1 table view settings
                if (level1TableView === 'table') {
                    const chartBtn = document.querySelector('[data-view="chart"]');
                    const tableBtn = document.querySelector('[data-view="table"]');
                    if (chartBtn && tableBtn) {
                        chartBtn.classList.remove('active');
                        tableBtn.classList.add('active');
                        document.getElementById('level1ChartView').style.display = 'none';
                        document.getElementById('level1TableView').style.display = 'block';
                    }
                }
                
                // Restore sort
                const sortSelect = document.getElementById('level1TableSort');
                if (sortSelect) {
                    sortSelect.value = level1TableSort;
                }
                
                // Restore filters after extension data is loaded
                // This will be done in loadExtensionData after data is loaded
                
            } catch (error) {
                console.error('Initialization error:', error);
                showEmptyState(`Initialization failed: ${error.message}`);
            }
        })();

        // Re-initialize app when authenticated
        window.addEventListener('appAuthenticated', function() {
            // Reload the page to re-run the init function
            location.reload();
        });
    </script>
    </div> <!-- End of mainApp -->
</body>
</html>

